{
  "language": "Solidity",
  "sources": {
    "contracts/Exchange1.sol": {
      "content": "pragma solidity 0.6.4;\n\ninterface TokenInterface {\n    function transfer(address, uint) external returns (bool);\n    function approve(address, uint) external;\n    function transferFrom(address, address, uint) external returns (bool);\n}\n\ncontract Exchange1 {\n\n\taddress public token_;\n\n\tevent TokenToEthPurchase(address indexed buyer, uint256 indexed tokensIn, uint256 indexed ethOut);\n\n\t// Creation event\n\tconstructor() public {}\n\n    receive() external payable {}\n\n    function setToken (address _address) public {\n        token_ = _address;\n    }\n\n    function getToken () external view returns (address) {\n        return token_;\n    }\n\n        // Buyer swaps Tokens for ETH\n    function tokenToEthSwapInput(uint256 _tokenAmount, uint256 _minEth, uint256 _timeout)\n        external returns (uint256  eth_bought)\n    {\n        require(_tokenAmount > 0 && _minEth > 0 && now < _timeout);\n        uint256 ethout = _tokenToEth(msg.sender, msg.sender, _tokenAmount, _minEth);\n        return ethout;\n    }\n\n\t    // Payer pays in Tokens, recipient receives ETH\n    function tokenToEthTransferInput(\n        uint256 _tokenAmount,\n        uint256 _minEth,\n        uint256 _timeout,\n        address payable _recipient\n    )\n        external returns (uint256  eth_bought)\n    {\n        require(_tokenAmount > 0 && _minEth > 0 && now < _timeout);\n        require(_recipient != address(0) && _recipient != address(this));\n        uint256 ethout = _tokenToEth(msg.sender, _recipient, _tokenAmount, _minEth);\n        return ethout;\n    }\n\n    function _tokenToEth(\n        address buyer,\n        address payable recipient,\n        uint256 tokensIn,\n        uint256 minEthOut\n    )\n        internal\n        returns (uint256  ethout)\n    {\n        require (minEthOut > 0);       \n    \tuint256 ethOut = 2000000000000000;\n        require(TokenInterface(token_).transferFrom(buyer, address(this), tokensIn));\n        emit TokenToEthPurchase(buyer, tokensIn, ethOut);\n        recipient.transfer(ethOut);\n        return ethOut;\n    }\n\n}"
    },
    "contracts/Exchange2.sol": {
      "content": "pragma solidity 0.6.4;\n\ninterface TokenInterface {\n    function transfer(address, uint) external returns (bool);\n    function approve(address, uint) external;\n    function transferFrom(address, address, uint) external returns (bool);\n}\n\ncontract Exchange2 {\n\n\taddress public token_;\n\n\tevent TokenToEthPurchase(address indexed buyer, uint256 indexed tokensIn, uint256 indexed ethOut);\n\n\t// Creation event\n\tconstructor() public {}\n\n    receive() external payable {}\n\n    function setToken (address _address) public {\n        token_ = _address;\n    }\n\n    function getToken () external view returns (address) {\n        return token_;\n    }\n\n        // Buyer swaps Tokens for ETH\n    function tokenToEthSwapInput(uint256 _tokenAmount, uint256 _minEth, uint256 _timeout)\n        external returns (uint256  eth_bought)\n    {\n        require(_tokenAmount > 0 && _minEth > 0 && now < _timeout);\n        uint256 ethout = _tokenToEth(msg.sender, msg.sender, _tokenAmount, _minEth);\n        return ethout;\n    }\n\n\t    // Payer pays in Tokens, recipient receives ETH\n    function tokenToEthTransferInput(\n        uint256 _tokenAmount,\n        uint256 _minEth,\n        uint256 _timeout,\n        address payable _recipient\n    )\n        external returns (uint256  eth_bought)\n    {\n        require(_tokenAmount > 0 && _minEth > 0 && now < _timeout);\n        require(_recipient != address(0) && _recipient != address(this));\n        uint256 ethout = _tokenToEth(msg.sender, _recipient, _tokenAmount, _minEth);\n        return ethout;\n    }\n\n    function _tokenToEth(\n        address buyer,\n        address payable recipient,\n        uint256 tokensIn,\n        uint256 minEthOut\n    )\n        internal\n        returns (uint256  ethout)\n    {\n        require (minEthOut > 0);       \n    \tuint256 ethOut = 2000000000000000;\n        require(TokenInterface(token_).transferFrom(buyer, address(this), tokensIn));\n        emit TokenToEthPurchase(buyer, tokensIn, ethOut);\n        recipient.transfer(ethOut);\n        return ethOut;\n    }\n\n}"
    },
    "contracts/Migrations.sol": {
      "content": "pragma solidity 0.6.4;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"
    },
    "contracts/Registry1.sol": {
      "content": "pragma solidity 0.6.4;\n\n\ncontract Registry1 {\n\nmapping (address => address) registry;\t\t// Token -> Exchange\n\n\n\t// Creation event\n\tconstructor() public {\n\n\t}\n\n\tfunction setExchange (address _exchange, address _token) public {\t\n\t\tregistry[_token] = _exchange;\n\t}\n\t\n\n\tfunction getExchange(address token) public view returns (address) {\n\t    //exchange = address(0x0000000000000000000000000000000000000000);\n\t    return registry[token];\n\t}\n\n}"
    },
    "contracts/Registry2.sol": {
      "content": "pragma solidity 0.6.4;\n\n\ncontract Registry2 {\n\nmapping (address => address) registry;\t\t// Token -> Exchange\n\n\n\t// Creation event\n\tconstructor() public {\n\n\t}\n\n\tfunction setExchange (address _exchange, address _token) public {\t\n\t\tregistry[_token] = _exchange;\n\t}\n\t\n\n\tfunction getExchange(address token) public view returns (address) {\n\t    //exchange = address(0x0000000000000000000000000000000000000000);\n\t    return registry[token];\n\t}\n\n}"
    },
    "contracts/Token1.sol": {
      "content": "pragma solidity 0.6.4;\n\n\n//IERC20 Interface\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address, uint) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// Token Contract\ncontract Token1 is ERC20 {\n\n    using SafeMath for uint256;\n\n    // Coin Defaults\n    string public name;                                         // Name of Coin\n    string public symbol;                                       // Symbol of Coin\n    uint256 public decimals  = 18;                              // Decimals\n    uint256 public override totalSupply  = 1000000 * (10 ** decimals);   // 1,000,000 Total\n\n    // Mapping\n    mapping(address => uint256) public override balanceOf;                          // Map balanceOf\n    mapping(address => mapping(address => uint256)) public override allowance;    // Map allowances\n    \n    // Events\n    event Approval(address indexed owner, address indexed spender, uint value); // ERC20\n    event Transfer(address indexed from, address indexed to, uint256 value);    // ERC20\n\n    // Minting event\n    constructor() public{\n        balanceOf[msg.sender] = totalSupply;\n        name = \"Token\";\n        symbol  = \"TKN\";\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n    \n    // ERC20\n    function transfer(address to, uint256 value) public override returns (bool success) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // ERC20\n    function approve(address spender, uint256 value) public override returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // ERC20\n    function transferFrom(address from, address to, uint256 value) public override returns (bool success) {\n        require(value <= allowance[from][msg.sender]);\n        allowance[from][msg.sender] -= value;\n        _transfer(from, to, value);\n        return true;\n    }\n\n    // Transfer function which includes the network fee\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != address(0));\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to].add(_value) >= balanceOf[_to]);                 // catch overflow       \n        \n        balanceOf[_from] = balanceOf[_from].sub(_value);                       // Subtract from sender         \n        balanceOf[_to] = balanceOf[_to].add(_value);                            // Add to receiver\n        \n        emit Transfer(_from, _to, _value);                    // Transaction event            \n    }\n}"
    },
    "contracts/Token2.sol": {
      "content": "pragma solidity 0.6.4;\n\n\n//IERC20 Interface\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address, uint) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// Token Contract\ncontract Token2 is ERC20 {\n\n    using SafeMath for uint256;\n\n    // Coin Defaults\n    string public name;                                         // Name of Coin\n    string public symbol;                                       // Symbol of Coin\n    uint256 public decimals  = 18;                              // Decimals\n    uint256 public override totalSupply  = 1000000 * (10 ** decimals);   // 1,000,000 Total\n\n    // Mapping\n    mapping(address => uint256) public override balanceOf;                          // Map balanceOf\n    mapping(address => mapping(address => uint256)) public override allowance;    // Map allowances\n    \n    // Events\n    event Approval(address indexed owner, address indexed spender, uint value); // ERC20\n    event Transfer(address indexed from, address indexed to, uint256 value);    // ERC20\n\n    // Minting event\n    constructor() public{\n        balanceOf[msg.sender] = totalSupply;\n        name = \"Token\";\n        symbol  = \"TKN\";\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n    \n    // ERC20\n    function transfer(address to, uint256 value) public override returns (bool success) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // ERC20\n    function approve(address spender, uint256 value) public override returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // ERC20\n    function transferFrom(address from, address to, uint256 value) public override returns (bool success) {\n        require(value <= allowance[from][msg.sender]);\n        allowance[from][msg.sender] -= value;\n        _transfer(from, to, value);\n        return true;\n    }\n\n    // Transfer function which includes the network fee\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != address(0));\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to].add(_value) >= balanceOf[_to]);                 // catch overflow       \n        \n        balanceOf[_from] = balanceOf[_from].sub(_value);                       // Subtract from sender         \n        balanceOf[_to] = balanceOf[_to].add(_value);                            // Add to receiver\n        \n        emit Transfer(_from, _to, _value);                    // Transaction event            \n    }\n}"
    },
    "contracts/Token3.sol": {
      "content": "pragma solidity 0.6.4;\n\n\n//IERC20 Interface\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address, uint) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// Token Contract\ncontract Token3 is ERC20 {\n\n    using SafeMath for uint256;\n\n    // Coin Defaults\n    string public name;                                         // Name of Coin\n    string public symbol;                                       // Symbol of Coin\n    uint256 public decimals  = 18;                              // Decimals\n    uint256 public override totalSupply  = 1000000 * (10 ** decimals);   // 1,000,000 Total\n\n    // Mapping\n    mapping(address => uint256) public override balanceOf;                          // Map balanceOf\n    mapping(address => mapping(address => uint256)) public override allowance;    // Map allowances\n    \n    // Events\n    event Approval(address indexed owner, address indexed spender, uint value); // ERC20\n    event Transfer(address indexed from, address indexed to, uint256 value);    // ERC20\n\n    // Minting event\n    constructor() public{\n        balanceOf[msg.sender] = totalSupply;\n        name = \"Token\";\n        symbol  = \"TKN\";\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n    \n    // ERC20\n    function transfer(address to, uint256 value) public override returns (bool success) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // ERC20\n    function approve(address spender, uint256 value) public override returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // ERC20\n    function transferFrom(address from, address to, uint256 value) public override returns (bool success) {\n        require(value <= allowance[from][msg.sender]);\n        allowance[from][msg.sender] -= value;\n        _transfer(from, to, value);\n        return true;\n    }\n\n    // Transfer function which includes the network fee\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != address(0));\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to].add(_value) >= balanceOf[_to]);                 // catch overflow       \n        \n        balanceOf[_from] = balanceOf[_from].sub(_value);                       // Subtract from sender         \n        balanceOf[_to] = balanceOf[_to].add(_value);                            // Add to receiver\n        \n        emit Transfer(_from, _to, _value);                    // Transaction event            \n    }\n}"
    },
    "contracts/Vether.sol": {
      "content": "pragma solidity 0.6.4;\n//ERC20 Interface\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address, uint256) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    }\n// Uniswap Factory Interface\ninterface UniswapFactory {\n    function getExchange(address token) external view returns (address exchange);\n    }\n// Uniswap Exchange Interface\ninterface UniswapExchange {\n    function tokenToEthTransferInput(uint256 tokens_sold,uint256 min_eth,uint256 deadline, address recipient) external returns (uint256  eth_bought);\n    }\n    //======================================VETHER=========================================//\ncontract Vether is ERC20 {\n    // ERC-20 Parameters\n    string public name; string public symbol;\n    uint256 public decimals; uint256 public override totalSupply;\n    // ERC-20 Mappings\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n    // Public Parameters\n    uint256 public emission;\n    uint256 public currentEra; uint256 public currentDay;\n    uint256 public daysPerEra; uint256 public secondsPerDay;\n    uint256 public genesis; uint256 public nextEraTime; uint256 public nextDayTime;\n    address payable public burnAddress;\n    address[2] public registryAddrArray; bool public registryAdded;\n    uint256 public totalFees; uint256 public totalBurnt;\n    // Public Mappings\n    mapping(uint256=>uint256) public mapEra_Emission;                                           // Era->Emission\n    mapping(uint256=>mapping(uint256=>uint256)) public mapEraDay_Units;                         // Era,Days->Units\n    mapping(uint256=>mapping(uint256=>uint256)) public mapEraDay_UnitsRemaining;                // Era,Days->TotalUnits\n    mapping(uint256=>mapping(uint256=>uint256)) public mapEraDay_Emission;                      // Era,Days->Emission\n    mapping(uint256=>mapping(uint256=>uint256)) public mapEraDay_EmissionRemaining;             // Era,Days->Emission\n    mapping(uint256=>mapping(uint256=>mapping(address=>uint256))) public mapEraDay_MemberUnits; // Era,Days,Member->Units\n    mapping(address=>mapping(uint256=>uint[])) public mapMemberEra_Days;                        // Member,Era->Days[]\n    // Events\n    event NewEra(uint256 era, uint256 emission, uint256 time);\n    event NewDay(uint256 era, uint256 day, uint256 time);\n    event Burn(address indexed payer, address indexed member, uint256 era, uint256 day, uint256 units);\n    event Withdrawal(address indexed caller, address indexed member, uint256 era, uint256 day, uint256 value);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() public {\n        //local\n        name = \"Vether\"; symbol = \"VETH\"; decimals = 18; totalSupply = 8190;\n        emission = 2048; currentEra = 1; currentDay = 1;                                    // Set emission, era and day\n        genesis = now; daysPerEra = 2; secondsPerDay = 1;                                   // Set genesis time\n        burnAddress = 0xE5904695748fe4A84b40b3fc79De2277660BD1D3;                           // TEST \n\n        //testnet\n        // name = \"Vether\"; symbol = \"VETH\"; decimals = 18; totalSupply = 16380*10**decimals;\n        // emission = 2048000000000000000000; currentEra = 1; currentDay = 1;               // Set emission, era and day\n        // genesis = now; daysPerEra = 4; secondsPerDay = 10000;                            // Set genesis time\n        // burnAddress = 0xa5d6fbDeA3F72c4289913BA0637DA417a41d8ED9;\n        // registryAddrArray[0] = 0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36;               // Set UniSwap V1 Rinkeby\n\n        // mainnet\n        // name = \"Vether\"; symbol = \"VETH\"; decimals = 18; totalSupply = 1000000*10**decimals;\n        // emission = 2048000000000000000000; currentEra = 1; currentDay = 1;               // Set emission, Era and Day\n        // genesis = now; daysPerEra = 244; secondsPerDay = 84196;                          // Set genesis time\n        // burnAddress = address(0);                                                        // Set Burn Address\n        // registryAddrArray[0] = 0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36;               // Set UniSwap V1 Mainnet\n        \n        balanceOf[address(this)] = totalSupply; \n        emit Transfer(address(0), address(this), totalSupply);                              // Mint the total supply to this address\n        nextEraTime = genesis + (secondsPerDay * daysPerEra);                               // Set next time for coin era\n        nextDayTime = genesis + secondsPerDay;                                              // Set next time for coin day\n        registryAdded = true;\n        mapEra_Emission[currentEra] = emission; \n        mapEraDay_EmissionRemaining[currentEra][currentDay] = emission; \n        mapEraDay_Emission[currentEra][currentDay] = emission;                               // Map Starting emission\n    }\n    //========================================ERC20=========================================//\n    // ERC20 Transfer function\n    function transfer(address to, uint256 value) public override returns (bool success) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n    // ERC20 Approve function\n    function approve(address spender, uint256 value) public override returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n    // ERC20 TransferFrom function\n    function transferFrom(address from, address to, uint256 value) public override returns (bool success) {\n        require(value <= allowance[from][msg.sender], 'Must not send more than allowance');\n        allowance[from][msg.sender] -= value;\n        _transfer(from, to, value);\n        return true;\n    }\n    // Internal transfer function which includes the Fee\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        require(balanceOf[_from] >= _value, 'Must not send more than balance');\n        require(balanceOf[_to] + _value >= balanceOf[_to], 'Balance overflow');\n        balanceOf[_from] -= _value;\n        uint256 _fee = _getFee(_from, _value);                                              // Get fee amount                                      // Subtract from sender\n        balanceOf[_to] += (_value - _fee);                                                  // Add to receiver\n        balanceOf[address(this)] += _fee;                                                   // Add fee to self\n        totalFees += _fee;                                                                  // Track fees collected\n        emit Transfer(_from, _to, (_value - _fee));                                         // Transfer event\n        if (_from != address(this)) {\n            emit Transfer(_from, address(this), _fee);                                      // Fee Transfer event\n        }\n    }\n    // Calculate Fee amount\n    function _getFee(address _from, uint256 _value) private view returns (uint256) {\n        if (_from == address(this)) {\n           return 0;                                                                        // No fee if this contract transfers\n        } else {\n            return (_value / 1000);                                                         // Fee amount = 0.1%\n        }\n    }\n    //==================================PROOF-OF-VALUE======================================//\n    // Calls when sending Ether\n    receive() external payable {\n        //burnAddress.transfer(msg.value);    \n        burnAddress.call.value(msg.value)(\"\");                                              // Burn ether\n        _recordBurn(msg.sender, msg.sender, currentEra, currentDay, msg.value);             // Record Burn\n    }\n    // Burn ether for nominated member\n    function burnEtherForMember(address member) external payable {\n        //burnAddress.transfer(msg.value);                                                    // Burn ether\n        burnAddress.call.value(msg.value)(\"\");                                              // Burn ether\n        _recordBurn(msg.sender, member, currentEra, currentDay, msg.value);                 // Record Burn\n    }\n    // Burn ERC-20 Tokens\n    function burnTokens(address token, uint256 amount) external {\n        _burnTokens(token, amount, msg.sender);                                             // Record Burn\n    }\n    // Burn tokens for nominated member\n    function burnTokensForMember(address token, uint256 amount, address member) external {\n        _burnTokens(token, amount, member);                                                 // Record Burn\n    }\n    // Calls when sending Tokens\n    function _burnTokens (address _token, uint256 _amount, address _member) internal {\n        uint256 _eth; address _ex = getExchange(_token);                                    // Get exchange\n        if (_ex == address(0)) {                                                            // Handle Token without Exchange\n            uint256 _startGas = gasleft();                                                  // Start counting gas\n            ERC20(_token).transferFrom(msg.sender, address(this), _amount);                 // Must collect tokens\n            ERC20(_token).transfer(burnAddress, _amount);                                   // Burn token\n            uint256 gasPrice = tx.gasprice; uint256 _endGas = gasleft();                    // Stop counting gas\n            uint256 _gasUsed = (_startGas - _endGas) + 20000;                               // Calculate gas and add gas overhead\n            _eth = _gasUsed * gasPrice;                                                     // Attribute gas burnt\n        } else {\n            ERC20(_token).transferFrom(msg.sender, address(this), _amount);                 // Must collect tokens\n            ERC20(_token).approve(_ex, _amount);                                            // Approve Exchange contract to transfer\n            _eth = UniswapExchange(_ex).tokenToEthTransferInput(\n                    _amount, 1, block.timestamp + 10, burnAddress);                         // Uniswap Exchange Transfer function\n        }\n        _recordBurn(msg.sender, _member, currentEra, currentDay, _eth);\n    }\n    // Get Token Exchange\n    function getExchange(address token ) public view returns (address){\n        address exchangeToReturn = address(0);\n        address exchangeFound = UniswapFactory(registryAddrArray[0]).getExchange(token);    // Try UniSwap V1\n        if (exchangeFound != address(0)) {\n            exchangeToReturn = exchangeFound;\n        } else {\n            exchangeToReturn = UniswapFactory(registryAddrArray[1]).getExchange(token);     // Try DefSwap\n        }\n        return exchangeToReturn;\n    }\n    // Internal - Records burn\n    function _recordBurn(address _payer, address _member, uint256 _era, uint256 _day, uint256 _eth) internal {\n        if (mapEraDay_MemberUnits[_era][_day][_member] == 0){                               // If hasn't contributed to this Day yet\n            mapMemberEra_Days[_member][_era].push(_day);                                    // Add it\n        }\n        mapEraDay_MemberUnits[_era][_day][_member] += _eth;                                 // Add member's share\n        mapEraDay_UnitsRemaining[_era][_day] += _eth;                                       // Add to total historicals\n        mapEraDay_Units[_era][_day] += _eth;                                                // Add to total outstanding\n        totalBurnt += _eth;                                                                 // Add to total burnt\n        emit Burn(_payer, _member, _era, _day, _eth);                                       // Burn event\n        _updateEmission();                                                                  // Update emission Schedule\n    }\n    // Allows updating of registry\n    function addRegistry(address registry, uint256 index) external {\n        if(!registryAdded){\n            require((UniswapFactory(registry).getExchange(address(0)) == address(0)), \"Must be valid Registry\");\n            _transfer(msg.sender, address(this), emission);\n            registryAdded = true;\n            registryAddrArray[index] = registry;\n        }\n    }\n    // ################-REMOVE_THIS_FOR_MAINNET-##########################\n    function addRegistryInternal(address registry, uint256 index) public {\n        registryAddrArray[index] = registry;\n    }\n    // ################-REMOVE_THIS_FOR_MAINNET-##########################\n    //======================================WITHDRAWAL======================================//\n    // Used to efficiently track participation in each era\n    function getDaysContributedForEra(address member, uint256 era) public view returns(uint256){\n        return mapMemberEra_Days[member][era].length;\n    }\n    // Call to withdraw a claim\n    function withdrawShare(uint256 era, uint256 day) external {\n        _withdrawShare(era, day, msg.sender);                           \n    }\n    // Call to withdraw a claim for another member\n    function withdrawShareForMember(uint256 era, uint256 day, address member) external {\n        _withdrawShare(era, day, member);\n    }\n    // Internal - withdraw function\n    function _withdrawShare (uint256 _era, uint256 _day, address _member) private {                                                                 // Update emission Schedule\n        _updateEmission();\n        if (_era < currentEra) {                                                            // Allow if in previous era\n            _processWithdrawal(_era, _day, _member);                                        // Process Withdrawal\n        } else if (_era == currentEra) {                                                    // Handle if in current era\n            if (_day < currentDay) {                                                        // Allow only if in previous day\n                _processWithdrawal(_era, _day, _member);                                    // Process Withdrawal\n            }\n        }   \n    }\n    // Internal - Withdrawal function\n    function _processWithdrawal (uint256 _era, uint256 _day, address _member) private {\n        uint256 memberUnits = mapEraDay_MemberUnits[_era][_day][_member];                   // Get Member Units\n        if (memberUnits == 0) {                                                             // Do nothing if 0 (prevents revert)\n        } else {\n            uint256 emissionToTransfer = getEmissionShare(_era, _day, _member);             // Get the emission Share for Member\n            mapEraDay_MemberUnits[_era][_day][_member] = 0;                                 // Set to 0 since it will be withdrawn\n            mapEraDay_UnitsRemaining[_era][_day] -= memberUnits;                            // Decrement Member Units\n            mapEraDay_EmissionRemaining[_era][_day] -= emissionToTransfer;                  // Decrement emission\n            _transfer(address(this), _member, emissionToTransfer);                          // ERC20 transfer function\n            emit Withdrawal(msg.sender, _member, _era, _day, emissionToTransfer);           // Withdrawal Event\n        }\n    }\n         // Get emission Share function\n    function getEmissionShare(uint256 era, uint256 day, address member) public view returns (uint256 emissionShare) {\n        uint256 memberUnits = mapEraDay_MemberUnits[era][day][member];                      // Get Member Units\n        if (memberUnits == 0) {\n            return 0;                                                                       // If 0, return 0\n        } else {\n            uint256 totalUnits = mapEraDay_UnitsRemaining[era][day];                        // Get Total Units\n            uint256 emissionRemaining = mapEraDay_EmissionRemaining[era][day];              // Get emission remaining for Day\n            uint256 balance = balanceOf[address(this)];                                     // Find remaining balance\n            if (emissionRemaining > balance) { emissionRemaining = balance; }               // In case less than required emission\n            emissionShare = (emissionRemaining * memberUnits) / totalUnits;                 // Calculate share\n            return  emissionShare;                            \n        }\n    }\n    //======================================EMISSION========================================//\n    // Internal - Update emission function\n    function _updateEmission() private {\n        uint256 _now = now;                                                                 // Find now()\n        if (_now >= nextDayTime) {                                                          // If time passed the next Day time\n            if (currentDay >= daysPerEra) {                                                 // If time passed the next Era time\n                currentEra += 1; currentDay = 0;                                            // Increment Era, reset Day\n                nextEraTime = _now + (secondsPerDay * daysPerEra);                          // Set next Era time\n                registryAdded = false;\n                emission = getNextEraEmission();                                            // Get correct emission\n                mapEra_Emission[currentEra] = emission;                                     // Map emission to Era\n                emit NewEra(currentEra, emission, nextEraTime);                             // Emit Event\n            }\n            currentDay += 1;                                                                // Increment Day\n            nextDayTime = _now + secondsPerDay;                                             // Set next Day time\n            emission = getDayEmission();                                                    // Check daily Dmission\n            mapEraDay_Emission[currentEra][currentDay] = emission;                          // Map emission to Day\n            mapEraDay_EmissionRemaining[currentEra][currentDay] = emission;                 // Map emission to Day\n            emit NewDay(currentEra, currentDay, nextDayTime);                               // Emit Event\n        }\n    }\n    // Calculate Era emission\n    function getNextEraEmission() public view returns (uint256) {\n        //uint256 _1 = 1000000000000000000;\n        uint256 _1 = 1;\n        if (emission > _1) {                                                                // Normal emission Schedule\n            return emission / 2;                                                            // emissions: 2048 -> 1.0\n        } else{                                                                             // Enters Fee Era\n            return _1;                                                                      // Return 1.0 from fees\n        }\n    }\n    // Calculate Day emission\n    function getDayEmission() public view returns (uint256) {\n        uint256 balance = balanceOf[address(this)];                                         // Find remaining balance\n        if (balance > emission) {                                                           // Balance is sufficient\n            return emission;                                                                // Return emission\n        } else {                                                                            // Balance has dropped low\n            return balance;                                                                 // Return full balance\n        }\n    }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}