{
  "language": "Solidity",
  "sources": {
    "contracts/Exchange1.sol": {
      "content": "pragma solidity 0.6.4;\n\ninterface TokenInterface {\n    function transfer(address, uint) external returns (bool);\n    function approve(address, uint) external;\n    function transferFrom(address, address, uint) external returns (bool);\n}\n\ncontract Exchange1 {\n\n\taddress public token_;\n\n\tevent TokenToEthPurchase(address indexed buyer, uint256 indexed tokensIn, uint256 indexed ethOut);\n\n\t// Creation event\n\tconstructor() public {}\n\n    receive() external payable {}\n\n    function setToken (address _address) public {\n        token_ = _address;\n    }\n\n    function getToken () external view returns (address) {\n        return token_;\n    }\n\n        // Buyer swaps Tokens for ETH\n    function tokenToEthSwapInput(uint256 _tokenAmount, uint256 _minEth, uint256 _timeout)\n        external returns (uint256  eth_bought)\n    {\n        require(_tokenAmount > 0 && _minEth > 0 && now < _timeout);\n        uint256 ethout = _tokenToEth(msg.sender, msg.sender, _tokenAmount, _minEth);\n        return ethout;\n    }\n\n\t    // Payer pays in Tokens, recipient receives ETH\n    function tokenToEthTransferInput(\n        uint256 _tokenAmount,\n        uint256 _minEth,\n        uint256 _timeout,\n        address payable _recipient\n    )\n        external returns (uint256  eth_bought)\n    {\n        require(_tokenAmount > 0 && _minEth > 0 && now < _timeout);\n        require(_recipient != address(0) && _recipient != address(this));\n        uint256 ethout = _tokenToEth(msg.sender, _recipient, _tokenAmount, _minEth);\n        return ethout;\n    }\n\n    function _tokenToEth(\n        address buyer,\n        address payable recipient,\n        uint256 tokensIn,\n        uint256 minEthOut\n    )\n        internal\n        returns (uint256  ethout)\n    {\n        require (minEthOut > 0);       \n    \tuint256 ethOut = 2000000000000000;\n        require(TokenInterface(token_).transferFrom(buyer, address(this), tokensIn));\n        emit TokenToEthPurchase(buyer, tokensIn, ethOut);\n        recipient.transfer(ethOut);\n        return ethOut;\n    }\n\n}"
    },
    "contracts/Exchange2.sol": {
      "content": "pragma solidity 0.6.4;\n\ninterface TokenInterface {\n    function transfer(address, uint) external returns (bool);\n    function approve(address, uint) external;\n    function transferFrom(address, address, uint) external returns (bool);\n}\n\ncontract Exchange2 {\n\n\taddress public token_;\n\n\tevent TokenToEthPurchase(address indexed buyer, uint256 indexed tokensIn, uint256 indexed ethOut);\n\n\t// Creation event\n\tconstructor() public {}\n\n    receive() external payable {}\n\n    function setToken (address _address) public {\n        token_ = _address;\n    }\n\n    function getToken () external view returns (address) {\n        return token_;\n    }\n\n        // Buyer swaps Tokens for ETH\n    function tokenToEthSwapInput(uint256 _tokenAmount, uint256 _minEth, uint256 _timeout)\n        external returns (uint256  eth_bought)\n    {\n        require(_tokenAmount > 0 && _minEth > 0 && now < _timeout);\n        uint256 ethout = _tokenToEth(msg.sender, msg.sender, _tokenAmount, _minEth);\n        return ethout;\n    }\n\n\t    // Payer pays in Tokens, recipient receives ETH\n    function tokenToEthTransferInput(\n        uint256 _tokenAmount,\n        uint256 _minEth,\n        uint256 _timeout,\n        address payable _recipient\n    )\n        external returns (uint256  eth_bought)\n    {\n        require(_tokenAmount > 0 && _minEth > 0 && now < _timeout);\n        require(_recipient != address(0) && _recipient != address(this));\n        uint256 ethout = _tokenToEth(msg.sender, _recipient, _tokenAmount, _minEth);\n        return ethout;\n    }\n\n    function _tokenToEth(\n        address buyer,\n        address payable recipient,\n        uint256 tokensIn,\n        uint256 minEthOut\n    )\n        internal\n        returns (uint256  ethout)\n    {\n        require (minEthOut > 0);       \n    \tuint256 ethOut = 2000000000000000;\n        require(TokenInterface(token_).transferFrom(buyer, address(this), tokensIn));\n        emit TokenToEthPurchase(buyer, tokensIn, ethOut);\n        recipient.transfer(ethOut);\n        return ethOut;\n    }\n\n}"
    },
    "contracts/GasMineContract.sol": {
      "content": "pragma solidity 0.6.4;\n\ninterface Vether {\n    function burnTokensForMember(address token, uint amount, address member) external;\n}\n\ninterface GasToken {\n    function approve(address, uint) external returns (bool);\n    function resetGas() external;\n}\n\ncontract GasMineContract {\n\n    address public gasToken;\n    address public vether;\n\n    constructor(address addressGasToken, address addressVether) public{\n        gasToken = addressGasToken;\n        vether = addressVether;\n        uint totalSupply = (2 ** 256) - 1;\n        GasToken(gasToken).approve(addressVether, totalSupply);\n    }\n\n    function mine() public {\n        Vether(vether).burnTokensForMember(gasToken, 1, msg.sender);\n        GasToken(gasToken).resetGas();\n    }\n}"
    },
    "contracts/GasToken-1.sol": {
      "content": "pragma solidity 0.6.4;\n\n//IERC20 Interface\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address, uint) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// Token Contract\ncontract GasToken is ERC20 {\n\n    // Coin Defaults\n    string public name = \"Gas Coin\";\n    string public symbol = \"VGC\";\n    uint256 public decimals  = 18;\n    uint256 public override totalSupply  = (2 ** 256) - 1;\n\n    address public burnAddress;\n    mapping (address => uint) public gasPrice;\n    mapping(uint => string) public gasStorage;\n    // Mapping\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n   \n\n    // Events\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // Minting event\n    constructor() public{\n        burnAddress = 0xE5904695748fe4A84b40b3fc79De2277660BD1D3;\n        balanceOf[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n    \n    // ERC20\n    function transfer(address to, uint256 value) public override returns (bool success) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // ERC20\n    function approve(address spender, uint256 value) public override returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // ERC20\n    function transferFrom(address from, address to, uint256 value) public override returns (bool success) {\n        require(value <= allowance[from][msg.sender]);\n        allowance[from][msg.sender] -= value;\n        _transfer(from, to, value);\n        return true;\n    }\n\n    // Transfer function which includes the gas storage\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);    \n        balanceOf[_from] = balanceOf[_from] - _value;        \n        balanceOf[_to] = balanceOf[_to] + _value;\n\n        if (_to == burnAddress) {\n            // gasPrice[msg.origin] = _value;\n            for(uint i = 0; i < _value; i++){\n                gasStorage[i]=\"GASSTORAGEGASSTORAGEGASTORAGEGASSTORAGEGASSTORAGEGASTORAGEGASSTORAGE\";\n            }\n        }\n        emit Transfer(_from, _to, _value);         \n    }\n\n    function resetGas() public {\n        // uint gasPrice = gasPrice(msg.origin);\n        for(uint i = 0; i < 15; i++){\n            gasStorage[i]=\"0\";\n        }\n    }\n}"
    },
    "contracts/GasToken.sol": {
      "content": "pragma solidity 0.6.4;\n\n//IERC20 Interface\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address, uint) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface Vether {\n    function burnTokensForMember(address token, uint amount, address member) external;\n}\n\n// Token Contract\ncontract GasToken is ERC20 {\n\n    // Coin Defaults\n    string public name = \"Gas Coin\";\n    string public symbol = \"VGC\";\n    uint256 public decimals  = 18;\n    uint256 public override totalSupply  = (2 ** 256) - 1;\n\n    address public burnAddress;\n    address public vether;\n\n    uint public gasCycles;\n    mapping (address => uint) public gasPrice;\n    mapping(uint => string) public gasStorage;\n\n    // Mapping\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    // Events\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // Minting event\n    constructor(address addressVether) public{\n        gasCycles = 15;\n        burnAddress = 0xE5904695748fe4A84b40b3fc79De2277660BD1D3;\n        vether = addressVether;\n        allowance[address(this)][addressVether] = totalSupply;\n        balanceOf[address(this)] = totalSupply;\n        emit Transfer(address(0), address(this), totalSupply);\n    }\n    \n    // ERC20\n    function transfer(address to, uint256 value) public override returns (bool success) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // ERC20\n    function approve(address spender, uint256 value) public override returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // ERC20\n    function transferFrom(address from, address to, uint256 value) public override returns (bool success) {\n        require(value <= allowance[from][msg.sender]);\n        allowance[from][msg.sender] -= value;\n        _transfer(from, to, value);\n        return true;\n    }\n\n    // Transfer function which includes the gas storage\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);    \n        balanceOf[_from] = balanceOf[_from] - _value;        \n        balanceOf[_to] = balanceOf[_to] + _value;\n\n        if (_to == burnAddress) {\n            for(uint i = 0; i < gasCycles; i++){\n                gasStorage[i]=\"GASSTORAGEGASSTORAGEGASTORAGEGASSTORAGEGASSTORAGEGASTORAGEGASSTORAGE\";\n            }\n        }\n        emit Transfer(_from, _to, _value);         \n    }\n\n    function mine() public {\n        Vether(vether).burnTokensForMember(address(this), 1, msg.sender);\n        resetGas();\n    }\n\n    function resetGas() public {\n        for(uint i = 0; i < gasCycles; i++){\n            gasStorage[i]=\"0\";\n        }\n    }\n    \n}"
    },
    "contracts/Migrations.sol": {
      "content": "pragma solidity 0.6.4;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"
    },
    "contracts/Pools.sol": {
      "content": "pragma solidity 0.6.4;\n\ninterface Vether {\n    function transferFrom(address from, address to, uint value) external returns (bool success);\n\tfunction transfer(address to, uint value) external returns (bool success);\n\t}\n\ncontract Pools {\n\n\taddress public vether;\n\tuint public balance;\n\n\t// Creation event\n\tconstructor(address _vether) public {\n\t\tvether = _vether;\n\t}\n\n\tfunction deposit (uint amount) public {\t\n\t\tVether(vether).transferFrom(msg.sender, address(this), amount);\n\t\tbalance += amount;\n\t}\n\t\n\n\tfunction withdraw() public {\n\t    Vether(vether).transfer(msg.sender, balance);\n\t\tbalance -= balance;\n\t}\n\n}"
    },
    "contracts/Registry1.sol": {
      "content": "pragma solidity 0.6.4;\n\n\ncontract Registry1 {\n\nmapping (address => address) registry;\t\t// Token -> Exchange\n\n\n\t// Creation event\n\tconstructor() public {\n\n\t}\n\n\tfunction setExchange (address _exchange, address _token) public {\t\n\t\tregistry[_token] = _exchange;\n\t}\n\t\n\n\tfunction getExchange(address token) public view returns (address) {\n\t    //exchange = address(0x0000000000000000000000000000000000000000);\n\t    return registry[token];\n\t}\n\n}"
    },
    "contracts/Registry2.sol": {
      "content": "pragma solidity 0.6.4;\n\n\ncontract Registry2 {\n\nmapping (address => address) registry;\t\t// Token -> Exchange\n\n\n\t// Creation event\n\tconstructor() public {\n\n\t}\n\n\tfunction setExchange (address _exchange, address _token) public {\t\n\t\tregistry[_token] = _exchange;\n\t}\n\t\n\n\tfunction getExchange(address token) public view returns (address) {\n\t    //exchange = address(0x0000000000000000000000000000000000000000);\n\t    return registry[token];\n\t}\n\n}"
    },
    "contracts/Token1.sol": {
      "content": "pragma solidity 0.6.4;\n\n\n//IERC20 Interface\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address, uint) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// Token Contract\ncontract Token1 is ERC20 {\n\n    using SafeMath for uint256;\n\n    // Coin Defaults\n    string public name;                                         // Name of Coin\n    string public symbol;                                       // Symbol of Coin\n    uint256 public decimals  = 18;                              // Decimals\n    uint256 public override totalSupply  = 1000000 * (10 ** decimals);   // 1,000,000 Total\n\n    // Mapping\n    mapping(address => uint256) public override balanceOf;                          // Map balanceOf\n    mapping(address => mapping(address => uint256)) public override allowance;    // Map allowances\n    \n    // Events\n    event Approval(address indexed owner, address indexed spender, uint value); // ERC20\n    event Transfer(address indexed from, address indexed to, uint256 value);    // ERC20\n\n    // Minting event\n    constructor() public{\n        balanceOf[msg.sender] = totalSupply;\n        name = \"Token\";\n        symbol  = \"TKN\";\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n    \n    // ERC20\n    function transfer(address to, uint256 value) public override returns (bool success) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // ERC20\n    function approve(address spender, uint256 value) public override returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // ERC20\n    function transferFrom(address from, address to, uint256 value) public override returns (bool success) {\n        require(value <= allowance[from][msg.sender]);\n        allowance[from][msg.sender] -= value;\n        _transfer(from, to, value);\n        return true;\n    }\n\n    // Transfer function which includes the network fee\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != address(0));\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to].add(_value) >= balanceOf[_to]);                 // catch overflow       \n        \n        balanceOf[_from] = balanceOf[_from].sub(_value);                       // Subtract from sender         \n        balanceOf[_to] = balanceOf[_to].add(_value);                            // Add to receiver\n        \n        emit Transfer(_from, _to, _value);                    // Transaction event            \n    }\n}"
    },
    "contracts/Token2.sol": {
      "content": "pragma solidity 0.6.4;\n\n\n//IERC20 Interface\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address, uint) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// Token Contract\ncontract Token2 is ERC20 {\n\n    using SafeMath for uint256;\n\n    // Coin Defaults\n    string public name;                                         // Name of Coin\n    string public symbol;                                       // Symbol of Coin\n    uint256 public decimals  = 18;                              // Decimals\n    uint256 public override totalSupply  = 1000000 * (10 ** decimals);   // 1,000,000 Total\n\n    // Mapping\n    mapping(address => uint256) public override balanceOf;                          // Map balanceOf\n    mapping(address => mapping(address => uint256)) public override allowance;    // Map allowances\n    \n    // Events\n    event Approval(address indexed owner, address indexed spender, uint value); // ERC20\n    event Transfer(address indexed from, address indexed to, uint256 value);    // ERC20\n\n    // Minting event\n    constructor() public{\n        balanceOf[msg.sender] = totalSupply;\n        name = \"Token\";\n        symbol  = \"TKN\";\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n    \n    // ERC20\n    function transfer(address to, uint256 value) public override returns (bool success) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // ERC20\n    function approve(address spender, uint256 value) public override returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // ERC20\n    function transferFrom(address from, address to, uint256 value) public override returns (bool success) {\n        require(value <= allowance[from][msg.sender]);\n        allowance[from][msg.sender] -= value;\n        _transfer(from, to, value);\n        return true;\n    }\n\n    // Transfer function which includes the network fee\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != address(0));\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to].add(_value) >= balanceOf[_to]);                 // catch overflow       \n        \n        balanceOf[_from] = balanceOf[_from].sub(_value);                       // Subtract from sender         \n        balanceOf[_to] = balanceOf[_to].add(_value);                            // Add to receiver\n        \n        emit Transfer(_from, _to, _value);                    // Transaction event            \n    }\n}"
    },
    "contracts/Token3.sol": {
      "content": "pragma solidity 0.6.4;\n\n\n//IERC20 Interface\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address, uint) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// Token Contract\ncontract Token3 is ERC20 {\n\n    using SafeMath for uint256;\n\n    // Coin Defaults\n    string public name;                                         // Name of Coin\n    string public symbol;                                       // Symbol of Coin\n    uint256 public decimals  = 18;                              // Decimals\n    uint256 public override totalSupply  = 1000000 * (10 ** decimals);   // 1,000,000 Total\n\n    // Mapping\n    mapping(address => uint256) public override balanceOf;                          // Map balanceOf\n    mapping(address => mapping(address => uint256)) public override allowance;    // Map allowances\n    \n    // Events\n    event Approval(address indexed owner, address indexed spender, uint value); // ERC20\n    event Transfer(address indexed from, address indexed to, uint256 value);    // ERC20\n\n    // Minting event\n    constructor() public{\n        balanceOf[msg.sender] = totalSupply;\n        name = \"Token\";\n        symbol  = \"TKN\";\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n    \n    // ERC20\n    function transfer(address to, uint256 value) public override returns (bool success) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // ERC20\n    function approve(address spender, uint256 value) public override returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // ERC20\n    function transferFrom(address from, address to, uint256 value) public override returns (bool success) {\n        require(value <= allowance[from][msg.sender]);\n        allowance[from][msg.sender] -= value;\n        _transfer(from, to, value);\n        return true;\n    }\n\n    // Transfer function which includes the network fee\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != address(0));\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to].add(_value) >= balanceOf[_to]);                 // catch overflow       \n        \n        balanceOf[_from] = balanceOf[_from].sub(_value);                       // Subtract from sender         \n        balanceOf[_to] = balanceOf[_to].add(_value);                            // Add to receiver\n        \n        emit Transfer(_from, _to, _value);                    // Transaction event            \n    }\n}"
    },
    "contracts/Vether1.sol": {
      "content": "pragma solidity 0.6.4;\n//ERC20 Interface\ninterface ERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address, uint) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    }\n// Uniswap Factory Interface\ninterface UniswapFactory {\n    function getExchange(address token) external view returns (address exchange);\n    }\n// Uniswap Exchange Interface\ninterface UniswapExchange {\n    function tokenToEthTransferInput(uint tokens_sold,uint min_eth,uint deadline, address recipient) external returns (uint  eth_bought);\n    }\n    //======================================VETHER=========================================//\ncontract Vether1 is ERC20 {\n    // ERC-20 Parameters\n    string public name; string public symbol;\n    uint public decimals; uint public override totalSupply;\n    // ERC-20 Mappings\n    mapping(address => uint) public override balanceOf;\n    mapping(address => mapping(address => uint)) public override allowance;\n    // Public Parameters\n    uint coin; uint public emission;\n    uint public currentEra; uint public currentDay;\n    uint public daysPerEra; uint public secondsPerDay;\n    uint public genesis; uint public nextEraTime; uint public nextDayTime;\n    address payable public burnAddress;\n    address public registryAddress;\n    uint public totalFees; uint public totalBurnt;\n    // Public Mappings\n    mapping(uint=>uint) public mapEra_Emission;                                             // Era->Emission\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_Units;                              // Era,Days->Units\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_UnitsRemaining;                     // Era,Days->TotalUnits\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_Emission;                           // Era,Days->Emission\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_EmissionRemaining;                  // Era,Days->Emission\n    mapping(uint=>mapping(uint=>mapping(address=>uint))) public mapEraDay_MemberUnits;      // Era,Days,Member->Units\n    mapping(address=>mapping(uint=>uint[])) public mapMemberEra_Days;                       // Member,Era->Days[]\n    mapping(address=>bool) public mapAddress_Excluded;                                      // Address->Excluded\n    // Events\n    event NewEra(uint era, uint emission, uint time);\n    event NewDay(uint era, uint day, uint time);\n    event Burn(address indexed payer, address indexed member, uint era, uint day, uint units);\n    event Withdrawal(address indexed caller, address indexed member, uint era, uint day, uint value);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() public {\n        //local\n        name = \"Vether\"; symbol = \"VETH\"; decimals = 18; \n        coin = 1; totalSupply = 64000*coin;\n        emission = 2048*coin; currentEra = 1; currentDay = 1;                               // Set emission, era and day\n        genesis = now; daysPerEra = 20; secondsPerDay = 2;                                   // Set genesis time\n        burnAddress = 0x0111011001100001011011000111010101100101;                           // TEST \n\n        //testnet\n        // name = \"Vether\"; symbol = \"VETH\"; decimals = 18; \n        // coin = 1*10**decimals; totalSupply = 16380*coin;\n        // emission = 2048*coin; currentEra = 1; currentDay = 1;                               // Set emission, era and day\n        // genesis = now; daysPerEra = 4; secondsPerDay = 10000;                               // Set genesis time\n        // burnAddress = 0xa5d6fbDeA3F72c4289913BA0637DA417a41d8ED9;\n        // registryAddressArray[0] = 0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36;               // Set UniSwap V1 Rinkeby\n\n        // mainnet\n        // name = \"Vether\"; symbol = \"VETH\"; decimals = 18; \n        // coin = 1*10**decimals; totalSupply = 1000000*coin;                                  // Set Supply\n        // emission = 2048*coin; currentEra = 1; currentDay = 1;                               // Set emission, Era and Day\n        // genesis = now; daysPerEra = 244; secondsPerDay = 84200;                             // Set genesis time\n        // burnAddress = 0x0111011001100001011011000111010101100101;                           // Set Burn Address\n        // registryAddress = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;                       // Set UniSwap V1 Mainnet\n        \n        balanceOf[address(this)] = totalSupply; \n        emit Transfer(address(0), address(this), totalSupply);                              // Mint the total supply to this address\n        nextEraTime = genesis + (secondsPerDay * daysPerEra);                               // Set next time for coin era\n        nextDayTime = genesis + secondsPerDay;                                              // Set next time for coin day\n        mapAddress_Excluded[address(this)] = true;                                          // Add this address to be excluded from fees\n        mapEra_Emission[currentEra] = emission;                                             // Map Starting emission\n        mapEraDay_EmissionRemaining[currentEra][currentDay] = emission; \n        mapEraDay_Emission[currentEra][currentDay] = emission;\n    }\n    // ################-REMOVE_THIS_FOR_MAINNET-##########################\n    // Allows testing. Remove for mainnet\n    function addRegistryInternal(address registry) public {\n        registryAddress = registry;\n    }\n    // ################-REMOVE_THIS_FOR_MAINNET-##########################\n    //========================================ERC20=========================================//\n    // ERC20 Transfer function\n    function transfer(address to, uint value) public override returns (bool success) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n    // ERC20 Approve function\n    function approve(address spender, uint value) public override returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n    // ERC20 TransferFrom function\n    function transferFrom(address from, address to, uint value) public override returns (bool success) {\n        require(value <= allowance[from][msg.sender], 'Must not send more than allowance');\n        allowance[from][msg.sender] -= value;\n        _transfer(from, to, value);\n        return true;\n    }\n    // Internal transfer function which includes the Fee\n    function _transfer(address _from, address _to, uint _value) private {\n        require(balanceOf[_from] >= _value, 'Must not send more than balance');\n        require(balanceOf[_to] + _value >= balanceOf[_to], 'Balance overflow');\n        balanceOf[_from] -= _value;\n        uint _fee = _getFee(_from, _to, _value);                                            // Get fee amount\n        balanceOf[_to] += (_value - _fee);                                                  // Add to receiver\n        balanceOf[address(this)] += _fee;                                                   // Add fee to self\n        totalFees += _fee;                                                                  // Track fees collected\n        emit Transfer(_from, _to, (_value - _fee));                                         // Transfer event\n        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {\n            emit Transfer(_from, address(this), _fee);                                      // Fee Transfer event\n        }\n    }\n    // Calculate Fee amount\n    function _getFee(address _from, address _to, uint _value) private view returns (uint) {\n        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {\n           return 0;                                                                        // No fee if excluded\n        } else {\n            return (_value / 1000);                                                         // Fee amount = 0.1%\n        }\n    }\n    //==================================PROOF-OF-VALUE======================================//\n    // Calls when sending Ether\n    receive() external payable {\n        burnAddress.call.value(msg.value)(\"\");                                              // Burn ether\n        _recordBurn(msg.sender, msg.sender, currentEra, currentDay, msg.value);             // Record Burn\n    }\n    // Burn ether for nominated member\n    function burnEtherForMember(address member) external payable {\n        burnAddress.call.value(msg.value)(\"\");                                              // Burn ether\n        _recordBurn(msg.sender, member, currentEra, currentDay, msg.value);                 // Record Burn\n    }\n    // Burn ERC-20 Tokens\n    function burnTokens(address token, uint amount) external {\n        _burnTokens(token, amount, msg.sender);                                             // Record Burn\n    }\n    // Burn tokens for nominated member\n    function burnTokensForMember(address token, uint amount, address member) external {\n        _burnTokens(token, amount, member);                                                 // Record Burn\n    }\n    // Calls when sending Tokens\n    function _burnTokens (address _token, uint _amount, address _member) private {\n        uint _eth; address _ex = getExchange(_token);                                       // Get exchange\n        if (_ex == address(0)) {                                                            // Handle Token without Exchange\n            uint _startGas = gasleft();                                                     // Start counting gas\n            ERC20(_token).transferFrom(msg.sender, address(this), _amount);                 // Must collect tokens\n            ERC20(_token).transfer(burnAddress, _amount);                                   // Burn token\n            uint gasPrice = tx.gasprice; uint _endGas = gasleft();                          // Stop counting gas\n            uint _gasUsed = (_startGas - _endGas) + 20000;                                  // Calculate gas and add gas overhead\n            _eth = _gasUsed * gasPrice;                                                     // Attribute gas burnt\n        } else {\n            ERC20(_token).transferFrom(msg.sender, address(this), _amount);                 // Must collect tokens\n            ERC20(_token).approve(_ex, _amount);                                            // Approve Exchange contract to transfer\n            _eth = UniswapExchange(_ex).tokenToEthTransferInput(\n                    _amount, 1, block.timestamp + 1000, burnAddress);                       // Uniswap Exchange Transfer function\n        }\n        _recordBurn(msg.sender, _member, currentEra, currentDay, _eth);\n    }\n    // Get Token Exchange\n    function getExchange(address token ) public view returns (address){\n        address exchangeToReturn = address(0);\n        address exchangeFound = UniswapFactory(registryAddress).getExchange(token);         // Try UniSwap V1\n        if (exchangeFound != address(0)) {\n            exchangeToReturn = exchangeFound;\n        }\n        return exchangeToReturn;\n    }\n    // Internal - Records burn\n    function _recordBurn(address _payer, address _member, uint _era, uint _day, uint _eth) private {\n        if (mapEraDay_MemberUnits[_era][_day][_member] == 0){                               // If hasn't contributed to this Day yet\n            mapMemberEra_Days[_member][_era].push(_day);                                    // Add it\n        }\n        mapEraDay_MemberUnits[_era][_day][_member] += _eth;                                 // Add member's share\n        mapEraDay_UnitsRemaining[_era][_day] += _eth;                                       // Add to total historicals\n        mapEraDay_Units[_era][_day] += _eth;                                                // Add to total outstanding\n        totalBurnt += _eth;                                                                 // Add to total burnt\n        emit Burn(_payer, _member, _era, _day, _eth);                                       // Burn event\n        _updateEmission();                                                                  // Update emission Schedule\n    }\n    // Allows adding an excluded address, once per Era\n    function addExcluded(address excluded) external {                   \n        _transfer(msg.sender, address(this), mapEra_Emission[1]/16);                        // Pay fee of 128 Vether\n        mapAddress_Excluded[excluded] = true;                                               // Add desired address\n    }\n    //======================================WITHDRAWAL======================================//\n    // Used to efficiently track participation in each era\n    function getDaysContributedForEra(address member, uint era) public view returns(uint){\n        return mapMemberEra_Days[member][era].length;\n    }\n    // Call to withdraw a claim\n    function withdrawShare(uint era, uint day) external {\n        _withdrawShare(era, day, msg.sender);                           \n    }\n    // Call to withdraw a claim for another member\n    function withdrawShareForMember(uint era, uint day, address member) external {\n        _withdrawShare(era, day, member);\n    }\n    // Internal - withdraw function\n    function _withdrawShare (uint _era, uint _day, address _member) private {               // Update emission Schedule\n        _updateEmission();\n        if (_era < currentEra) {                                                            // Allow if in previous Era\n            _processWithdrawal(_era, _day, _member);                                        // Process Withdrawal\n        } else if (_era == currentEra) {                                                    // Handle if in current Era\n            if (_day < currentDay) {                                                        // Allow only if in previous Day\n                _processWithdrawal(_era, _day, _member);                                    // Process Withdrawal\n            }\n        }   \n    }\n    // Internal - Withdrawal function\n    function _processWithdrawal (uint _era, uint _day, address _member) private {\n        uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member];                      // Get Member Units\n        if (memberUnits == 0) {                                                             // Do nothing if 0 (prevents revert)\n        } else {\n            uint emissionToTransfer = getEmissionShare(_era, _day, _member);                // Get the emission Share for Member\n            mapEraDay_MemberUnits[_era][_day][_member] = 0;                                 // Set to 0 since it will be withdrawn\n            mapEraDay_UnitsRemaining[_era][_day] -= memberUnits;                            // Decrement Member Units\n            mapEraDay_EmissionRemaining[_era][_day] -= emissionToTransfer;                  // Decrement emission\n            _transfer(address(this), _member, emissionToTransfer);                          // ERC20 transfer function\n            emit Withdrawal(msg.sender, _member, _era, _day, emissionToTransfer);           // Withdrawal Event\n        }\n    }\n         // Get emission Share function\n    function getEmissionShare(uint era, uint day, address member) public view returns (uint emissionShare) {\n        uint memberUnits = mapEraDay_MemberUnits[era][day][member];                         // Get Member Units\n        if (memberUnits == 0) {\n            return 0;                                                                       // If 0, return 0\n        } else {\n            uint totalUnits = mapEraDay_UnitsRemaining[era][day];                           // Get Total Units\n            uint emissionRemaining = mapEraDay_EmissionRemaining[era][day];                 // Get emission remaining for Day\n            uint balance = balanceOf[address(this)];                                        // Find remaining balance\n            if (emissionRemaining > balance) { emissionRemaining = balance; }               // In case less than required emission\n            emissionShare = (emissionRemaining * memberUnits) / totalUnits;                 // Calculate share\n            return  emissionShare;                            \n        }\n    }\n    //======================================EMISSION========================================//\n    // Internal - Update emission function\n    function _updateEmission() private {\n        uint _now = now;                                                                    // Find now()\n        if (_now >= nextDayTime) {                                                          // If time passed the next Day time\n            if (currentDay >= daysPerEra) {                                                 // If time passed the next Era time\n                currentEra += 1; currentDay = 0;                                            // Increment Era, reset Day\n                nextEraTime = _now + (secondsPerDay * daysPerEra);                          // Set next Era time\n                emission = getNextEraEmission();                                            // Get correct emission\n                mapEra_Emission[currentEra] = emission;                                     // Map emission to Era\n                emit NewEra(currentEra, emission, nextEraTime);                             // Emit Event\n            }\n            currentDay += 1;                                                                // Increment Day\n            nextDayTime = _now + secondsPerDay;                                             // Set next Day time\n            emission = getDayEmission();                                                    // Check daily Dmission\n            mapEraDay_Emission[currentEra][currentDay] = emission;                          // Map emission to Day\n            mapEraDay_EmissionRemaining[currentEra][currentDay] = emission;                 // Map emission to Day\n            emit NewDay(currentEra, currentDay, nextDayTime);                               // Emit Event\n        }\n    }\n    // Calculate Era emission\n    function getNextEraEmission() public view returns (uint) {\n        if (emission > coin) {                                                              // Normal Emission Schedule\n            return emission / 2;                                                            // Emissions: 2048 -> 1.0\n        } else{                                                                             // Enters Fee Era\n            return coin;                                                                    // Return 1.0 from fees\n        }\n    }\n    // Calculate Day emission\n    function getDayEmission() public view returns (uint) {\n        uint balance = balanceOf[address(this)];                                            // Find remaining balance\n        if (balance > emission) {                                                           // Balance is sufficient\n            return emission;                                                                // Return emission\n        } else {                                                                            // Balance has dropped low\n            return balance;                                                                 // Return full balance\n        }\n    }\n}"
    },
    "contracts/Vether2.sol": {
      "content": "pragma solidity 0.6.4;\n//ERC20 Interface\ninterface ERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address, uint) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    }\ninterface VETH {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint);\n    function totalSupply() external view returns (uint);\n    function genesis() external view returns (uint);\n    function currentEra() external view returns (uint);\n    function currentDay() external view returns (uint);\n    function emission() external view returns (uint);\n    function daysPerEra() external view returns (uint);\n    function secondsPerDay() external view returns (uint);\n    function totalBurnt() external view returns (uint);\n    function totalFees() external view returns (uint);\n    function burnAddress() external view returns (address payable);\n}\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n}\n    //======================================VETHER=========================================//\ncontract Vether2 is ERC20 {\n    using SafeMath for uint;\n    // ERC-20 Parameters\n    string public name; string public symbol;\n    uint public decimals; uint public override totalSupply;\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n    // Public Parameters\n    uint coin = 1; uint public emission;\n    uint public currentEra; uint public currentDay;\n    uint public daysPerEra; uint public secondsPerDay;\n    uint public upgradeHeight; uint public upgradedAmount;\n    uint public genesis; uint public nextEraTime; uint public nextDayTime;\n    address payable public burnAddress; address public vether1; address deployer;\n    uint public totalFees; uint public totalBurnt; uint public totalEmitted;\n    address[] public holderArray; uint public holders;\n    // Public Mappings\n    mapping(uint=>uint) public mapEra_Emission;                                             // Era->Emission\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_MemberCount;                        // Era,Days->MemberCount\n    mapping(uint=>mapping(uint=>address[])) public mapEraDay_Members;                       // Era,Days->Members\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_Units;                              // Era,Days->Units\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_UnitsRemaining;                     // Era,Days->TotalUnits\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_Emission;                           // Era,Days->Emission\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_EmissionRemaining;                  // Era,Days->Emission\n    mapping(uint=>mapping(uint=>mapping(address=>uint))) public mapEraDay_MemberUnits;      // Era,Days,Member->Units\n    mapping(address=>mapping(uint=>uint[])) public mapMemberEra_Days;                       // Member,Era->Days[]\n    mapping(address=>bool) public mapAddress_Excluded;                                      // Address->Excluded\n    mapping(address=>uint) public mapPreviousOwnership;                                     // Map previous owners\n    mapping(address=>bool) public mapHolder;                                                // Vether Holder\n    // Events\n    event NewEra(uint era, uint emission, uint time, uint totalBurnt);\n    event NewDay(uint era, uint day, uint time, uint previousDayTotal, uint previousDayMembers);\n    event Burn(address indexed payer, address indexed member, uint era, uint day, uint units, uint dailyTotal);\n    event Withdrawal(address indexed caller, address indexed member, uint era, uint day, uint value, uint vetherRemaining);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor(address _vether1) public {\n        vether1 = _vether1;                                                                   // First Vether\n        upgradeHeight = 3;                                                                  // Height at which to upgrade\n        name = VETH(vether1).name(); \n        symbol = VETH(vether1).symbol(); \n        decimals = VETH(vether1).decimals(); \n        totalSupply = VETH(vether1).totalSupply();\n        genesis = VETH(vether1).genesis();\n        currentEra = VETH(vether1).currentEra(); \n        currentDay = upgradeHeight;                                                         // Begin at Upgrade Height\n        emission = VETH(vether1).emission(); \n        daysPerEra = VETH(vether1).daysPerEra(); \n        secondsPerDay = VETH(vether1).secondsPerDay();\n        totalBurnt = VETH(vether1).totalBurnt(); \n        totalFees = VETH(vether1).totalFees(); \n        totalEmitted = (upgradeHeight-1)*emission;\n        burnAddress = VETH(vether1).burnAddress(); \n        deployer = msg.sender;\n        _balances[address(this)] = totalSupply; \n        emit Transfer(burnAddress, address(this), totalSupply);                             // Mint the total supply to this address\n        nextEraTime = genesis + (secondsPerDay * daysPerEra);                               // Set next time for coin era\n        nextDayTime = genesis + (secondsPerDay * upgradeHeight);                            // Set next time for coin day\n        mapAddress_Excluded[address(this)] = true;                                          // Add this address to be excluded from fees\n        mapEra_Emission[currentEra] = emission;                                             // Map Starting emission\n        mapEraDay_EmissionRemaining[currentEra][currentDay] = emission; \n        mapEraDay_Emission[currentEra][currentDay] = emission;\n    }\n\n    //========================================ERC20=========================================//\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        if(mapAddress_Excluded[spender]){\n            return totalSupply;\n        } else {\n            return _allowances[owner][spender];\n        }\n    }\n    // ERC20 Transfer function\n    function transfer(address to, uint value) public override returns (bool success) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n    // ERC20 Approve function\n    function approve(address spender, uint value) public override returns (bool success) {\n        _allowances[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n    // ERC20 TransferFrom function\n    function transferFrom(address from, address to, uint value) public override returns (bool success) {\n        if(!mapAddress_Excluded[msg.sender]){\n            require(value <= _allowances[from][msg.sender], 'Must not send more than allowance');\n            _allowances[from][msg.sender] -= value;\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n    // Internal transfer function which includes the Fee\n    function _transfer(address _from, address _to, uint _value) private {\n        require(_balances[_from] >= _value, 'Must not send more than balance');\n        require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');\n        if(!mapHolder[_to]){holderArray.push(_to); holders+=1; mapHolder[_to]=true;}\n        _balances[_from] -= _value;\n        uint _fee = _getFee(_from, _to, _value);                                            // Get fee amount\n        _balances[_to] += (_value.sub(_fee));                                               // Add to receiver\n        _balances[address(this)] += _fee;                                                   // Add fee to self\n        totalFees += _fee;                                                                  // Track fees collected\n        emit Transfer(_from, _to, (_value.sub(_fee)));                                      // Transfer event\n        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {\n            emit Transfer(_from, address(this), _fee);                                      // Fee Transfer event\n        }\n    }\n    // Calculate Fee amount\n    function _getFee(address _from, address _to, uint _value) private view returns (uint) {\n        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {\n           return 0;                                                                        // No fee if excluded\n        } else {\n            return (_value / 1000);                                                         // Fee amount = 0.1%\n        }\n    }\n    // Allow to query for remaining upgrade amount\n    function getRemainingAmount() public view returns (uint amount){\n        uint maxEmissions = (upgradeHeight-1) * mapEra_Emission[1];                         // Max Emission on Old Contract\n        uint maxUpgradeAmount = (maxEmissions).sub(VETH(vether1).totalFees());              // Minus any collected fees\n        if(maxUpgradeAmount >= upgradedAmount){\n            return maxUpgradeAmount.sub(upgradedAmount);                                    // Return remaining\n        } else {\n            return 0;                                                                       // Return 0\n        }\n    }\n    // Allow any holder of the old asset to upgrade\n    function upgrade(uint amount) public returns (bool success){\n        uint _amount = amount;\n        if(mapPreviousOwnership[msg.sender] < amount){_amount = mapPreviousOwnership[msg.sender];} // Upgrade as much as possible\n        uint remainingAmount = getRemainingAmount();\n        if(remainingAmount < amount){_amount = remainingAmount;}                            // Handle final amount\n        upgradedAmount += _amount; mapPreviousOwnership[msg.sender] -= _amount;             // Update mappings\n        ERC20(vether1).transferFrom(msg.sender, burnAddress, _amount);                      // Must collect & burn tokens\n        _transfer(address(this), msg.sender, _amount);                                      // Send to owner\n        return true;\n    }\n    function snapshot(address[] memory owners, uint[] memory ownership) public{\n        require(msg.sender == deployer);\n        for(uint i = 0; i<owners.length; i++){\n            mapPreviousOwnership[owners[i]] = ownership[i];\n        }\n    }\n    function purgeDeployer() public{require(msg.sender == deployer);deployer = address(0);}\n\n    //==================================PROOF-OF-VALUE======================================//\n    // Calls when sending Ether\n    receive() external payable {\n        burnAddress.call.value(msg.value)(\"\");                                              // Burn ether\n        _recordBurn(msg.sender, msg.sender, currentEra, currentDay, msg.value);             // Record Burn\n    }\n    // Burn ether for nominated member\n    function burnEtherForMember(address member) external payable {\n        burnAddress.call.value(msg.value)(\"\");                                              // Burn ether\n        _recordBurn(msg.sender, member, currentEra, currentDay, msg.value);                 // Record Burn\n    }\n    // Internal - Records burn\n    function _recordBurn(address _payer, address _member, uint _era, uint _day, uint _eth) private {\n        require(VETH(vether1).currentDay() >= upgradeHeight || VETH(vether1).currentEra() > 1); // Prohibit until upgrade height\n        if (mapEraDay_MemberUnits[_era][_day][_member] == 0){                               // If hasn't contributed to this Day yet\n            mapMemberEra_Days[_member][_era].push(_day);                                    // Add it\n            mapEraDay_MemberCount[_era][_day] += 1;                                         // Count member\n            mapEraDay_Members[_era][_day].push(_member);                                    // Add member\n        }\n        mapEraDay_MemberUnits[_era][_day][_member] += _eth;                                 // Add member's share\n        mapEraDay_UnitsRemaining[_era][_day] += _eth;                                       // Add to total historicals\n        mapEraDay_Units[_era][_day] += _eth;                                                // Add to total outstanding\n        totalBurnt += _eth;                                                                 // Add to total burnt\n        emit Burn(_payer, _member, _era, _day, _eth, mapEraDay_Units[_era][_day]);          // Burn event\n        _updateEmission();                                                                  // Update emission Schedule\n    }\n    // Allows changing an excluded address\n    function changeExcluded(address excluded) external {    \n        if(!mapAddress_Excluded[excluded]){\n            _transfer(msg.sender, address(this), mapEra_Emission[1]/16);                    // Pay fee of 128 Vether\n            mapAddress_Excluded[excluded] = true;                                           // Add desired address\n            totalFees += mapEra_Emission[1]/16;\n        } else {\n            _transfer(msg.sender, address(this), mapEra_Emission[1]/32);                    // Pay fee of 64 Vether\n            mapAddress_Excluded[excluded] = false;                                          // Change desired address\n            totalFees += mapEra_Emission[1]/32;\n        }               \n    }\n    //======================================WITHDRAWAL======================================//\n    // Used to efficiently track participation in each era\n    function getDaysContributedForEra(address member, uint era) public view returns(uint){\n        return mapMemberEra_Days[member][era].length;\n    }\n    // Call to withdraw a claim\n    function withdrawShare(uint era, uint day) external returns (uint value) {\n        value = _withdrawShare(era, day, msg.sender);                           \n    }\n    // Call to withdraw a claim for another member\n    function withdrawShareForMember(uint era, uint day, address member) external returns (uint value) {\n        value = _withdrawShare(era, day, member);\n    }\n    // Internal - withdraw function\n    function _withdrawShare (uint _era, uint _day, address _member) private returns (uint value) {\n        _updateEmission(); \n        if (_era < currentEra) {                                                            // Allow if in previous Era\n            value = _processWithdrawal(_era, _day, _member);                                // Process Withdrawal\n        } else if (_era == currentEra) {                                                    // Handle if in current Era\n            if (_day < currentDay) {                                                        // Allow only if in previous Day\n                value = _processWithdrawal(_era, _day, _member);                            // Process Withdrawal\n            }\n        }  \n        return value;\n    }\n    // Internal - Withdrawal function\n    function _processWithdrawal (uint _era, uint _day, address _member) private returns (uint value) {\n        uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member];                      // Get Member Units\n        if (memberUnits == 0) { \n            value = 0;                                                                      // Do nothing if 0 (prevents revert)\n        } else {\n            value = getEmissionShare(_era, _day, _member);                                  // Get the emission Share for Member\n            mapEraDay_MemberUnits[_era][_day][_member] = 0;                                 // Set to 0 since it will be withdrawn\n            mapEraDay_UnitsRemaining[_era][_day] -= memberUnits;                            // Decrement Member Units\n            mapEraDay_EmissionRemaining[_era][_day] -= value;                               // Decrement emission\n            totalEmitted += value;                                                          // Add to Total Emitted\n            _transfer(address(this), _member, value);                                       // ERC20 transfer function\n            emit Withdrawal(msg.sender, _member, _era, _day, \n            value, mapEraDay_EmissionRemaining[_era][_day]);\n        }\n        return value;\n    }\n    // Get emission Share function\n    function getEmissionShare(uint era, uint day, address member) public view returns (uint value) {\n        uint memberUnits = mapEraDay_MemberUnits[era][day][member];                         // Get Member Units\n        if (memberUnits == 0) {\n            return 0;                                                                       // If 0, return 0\n        } else {\n            uint totalUnits = mapEraDay_UnitsRemaining[era][day];                           // Get Total Units\n            uint emissionRemaining = mapEraDay_EmissionRemaining[era][day];                 // Get emission remaining for Day\n            uint balance = _balances[address(this)];                                        // Find remaining balance\n            if (emissionRemaining > balance) { emissionRemaining = balance; }               // In case less than required emission\n            value = (emissionRemaining * memberUnits) / totalUnits;                         // Calculate share\n            return  value;                            \n        }\n    }\n    //======================================EMISSION========================================//\n    // Internal - Update emission function\n    function _updateEmission() private {\n        uint _now = now;                                                                    // Find now()\n        if (_now >= nextDayTime) {                                                          // If time passed the next Day time\n            if (currentDay >= daysPerEra) {                                                 // If time passed the next Era time\n                currentEra += 1; currentDay = 0;                                            // Increment Era, reset Day\n                nextEraTime = _now + (secondsPerDay * daysPerEra);                          // Set next Era time\n                emission = getNextEraEmission();                                            // Get correct emission\n                mapEra_Emission[currentEra] = emission;                                     // Map emission to Era\n                emit NewEra(currentEra, emission, nextEraTime, totalBurnt);                 // Emit Event\n            }\n            currentDay += 1;                                                                // Increment Day\n            nextDayTime = _now + secondsPerDay;                                             // Set next Day time\n            emission = getDayEmission();                                                    // Check daily Dmission\n            mapEraDay_Emission[currentEra][currentDay] = emission;                          // Map emission to Day\n            mapEraDay_EmissionRemaining[currentEra][currentDay] = emission;                 // Map emission to Day\n            uint _era = currentEra; uint _day = currentDay-1;\n            if(currentDay == 1){ _era = currentEra-1; _day = daysPerEra; }                  // Handle New Era\n            emit NewDay(currentEra, currentDay, nextDayTime, \n            mapEraDay_Units[_era][_day], mapEraDay_MemberCount[_era][_day]);                // Emit Event\n        }\n    }\n    // Calculate Era emission\n    function getNextEraEmission() public view returns (uint) {\n        if (emission > coin) {                                                              // Normal Emission Schedule\n            return emission / 2;                                                            // Emissions: 2048 -> 1.0\n        } else{                                                                             // Enters Fee Era\n            return coin;                                                                    // Return 1.0 from fees\n        }\n    }\n    // Calculate Day emission\n    function getDayEmission() public view returns (uint) {\n        uint balance = _balances[address(this)];                                            // Find remaining balance\n        if (balance > emission) {                                                           // Balance is sufficient\n            return emission;                                                                // Return emission\n        } else {                                                                            // Balance has dropped low\n            return balance;                                                                 // Return full balance\n        }\n    }\n}"
    },
    "contracts/Vether3.sol": {
      "content": "pragma solidity 0.6.4;\n//ERC20 Interface\ninterface ERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address, uint) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    }\ninterface VETH {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint);\n    function totalSupply() external view returns (uint);\n    function genesis() external view returns (uint);\n    function currentEra() external view returns (uint);\n    function currentDay() external view returns (uint);\n    function emission() external view returns (uint);\n    function daysPerEra() external view returns (uint);\n    function secondsPerDay() external view returns (uint);\n    function nextDayTime() external view returns (uint);\n    function totalBurnt() external view returns (uint);\n    function totalFees() external view returns (uint);\n    function burnAddress() external view returns (address payable);\n    function upgradeHeight() external view returns (uint);\n    function mapEraDay_Units(uint, uint) external view returns (uint);\n    function mapPreviousOwnership(address payable) external view returns (uint);\n}\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n}\n    //======================================VETHER=========================================//\ncontract Vether3 is ERC20 {\n    using SafeMath for uint;\n    // ERC-20 Parameters\n    string public name; string public symbol;\n    uint public decimals; uint public override totalSupply;\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n    // Public Parameters\n    uint coin = 1; uint public emission;\n    uint public currentEra; uint public currentDay;\n    uint public daysPerEra; uint public secondsPerDay;\n    uint public upgradeHeight; uint public upgradedAmount;\n    uint public genesis; uint public nextEraTime; uint public nextDayTime;\n    address payable public burnAddress; address public vether1; address public vether2; address deployer;\n    uint public totalFees; uint public totalBurnt; uint public totalEmitted;\n    address[] public holderArray; uint public holders;\n    address[] public excludedArray; uint public excludedCount;\n    // Public Mappings\n    mapping(uint=>uint) public mapEra_Emission;                                             // Era->Emission\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_MemberCount;                        // Era,Days->MemberCount\n    mapping(uint=>mapping(uint=>address[])) public mapEraDay_Members;                       // Era,Days->Members\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_Units;                              // Era,Days->Units\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_UnitsRemaining;                     // Era,Days->TotalUnits\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_EmissionRemaining;                  // Era,Days->Emission\n    mapping(uint=>mapping(uint=>mapping(address=>uint))) public mapEraDay_MemberUnits;      // Era,Days,Member->Units\n    mapping(address=>mapping(uint=>uint[])) public mapMemberEra_Days;                       // Member,Era->Days[]\n    mapping(address=>uint) public mapPreviousOwnership;                                     // Map previous owners\n    mapping(address=>bool) public mapHolder;                                                // Vether Holder\n    mapping(address=>bool) public mapAddress_Excluded;                                      // Address->Excluded\n    mapping(address=>uint) public mapAddress_BlockChange;                                   // Address->BlockHeight Change\n    // Events\n    event NewEra(uint era, uint emission, uint time, uint totalBurnt);\n    event NewDay(uint era, uint day, uint time, uint previousDayTotal, uint previousDayMembers);\n    event Burn(address indexed payer, address indexed member, uint era, uint day, uint units, uint dailyTotal);\n    event Withdrawal(address indexed caller, address indexed member, uint era, uint day, uint value, uint vetherRemaining);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor(address _vether1, address _vether2) public {\n        vether1 = _vether1;                                // First Vether\n        vether2 = _vether2;                                // Second Vether\n        upgradeHeight = 5;                                                                  // Height at which to upgrade\n        name = VETH(vether2).name(); symbol = VETH(vether2).symbol();\n        decimals = VETH(vether2).decimals(); totalSupply = VETH(vether2).totalSupply();\n        genesis = VETH(vether2).genesis(); emission = VETH(vether2).emission(); \n        currentEra = VETH(vether2).currentEra(); currentDay = upgradeHeight;                // Begin at Upgrade Height\n        daysPerEra = VETH(vether2).daysPerEra(); secondsPerDay = VETH(vether2).secondsPerDay();\n        totalBurnt = VETH(vether2).totalBurnt(); totalFees = VETH(vether2).totalFees();\n        totalEmitted = (upgradeHeight-1)*emission;\n        burnAddress = VETH(vether2).burnAddress(); deployer = msg.sender;\n        _balances[address(this)] = totalSupply; \n        emit Transfer(burnAddress, address(this), totalSupply);\n        nextEraTime = genesis + (secondsPerDay * daysPerEra);\n        nextDayTime = VETH(vether2).nextDayTime() + (secondsPerDay * (upgradeHeight - VETH(vether2).currentDay())); \n        mapAddress_Excluded[address(this)] = true;                                          \n        excludedArray.push(address(this)); excludedCount =1;                               \n        mapAddress_Excluded[burnAddress] = true;\n        excludedArray.push(burnAddress); excludedCount +=1; \n        mapEra_Emission[currentEra] = emission; \n        mapEraDay_EmissionRemaining[currentEra][currentDay] = emission; \n        _setMappings();                                                                  // Map historical units\n    }\n    function _setMappings() internal {\n        uint upgradeHeight1 = VETH(vether2).upgradeHeight();                \n        for(uint i=0;i<upgradeHeight1; i++) {\n            mapEraDay_Units[1][i] = VETH(vether1).mapEraDay_Units(1,i); \n        }\n        for(uint i=upgradeHeight1;i<upgradeHeight; i++) {\n            mapEraDay_Units[1][i] = VETH(vether2).mapEraDay_Units(1,i); \n        }\n    }\n\n    //========================================ERC20=========================================//\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        if(mapAddress_Excluded[spender]){\n            return totalSupply;\n        } else {\n            return _allowances[owner][spender];\n        }\n    }\n    // ERC20 Transfer function\n    function transfer(address to, uint value) public override returns (bool success) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n    // ERC20 Approve function\n    function approve(address spender, uint value) public override returns (bool success) {\n        _allowances[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n    // ERC20 TransferFrom function\n    function transferFrom(address from, address to, uint value) public override returns (bool success) {\n        if(!mapAddress_Excluded[msg.sender]){\n            require(value <= _allowances[from][msg.sender], 'Must not send more than allowance');\n            _allowances[from][msg.sender] -= value;\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n    // Internal transfer function which includes the Fee\n    function _transfer(address _from, address _to, uint _value) private {\n        require(_balances[_from] >= _value, 'Must not send more than balance');\n        require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');\n        if(!mapHolder[_to]){holderArray.push(_to); holders+=1; mapHolder[_to]=true;}\n        _balances[_from] =_balances[_from].sub(_value);\n        uint _fee = _getFee(_from, _to, _value);                                            // Get fee amount\n        _balances[_to] += (_value.sub(_fee));                                               // Add to receiver\n        _balances[address(this)] += _fee;                                                   // Add fee to self\n        totalFees += _fee;                                                                  // Track fees collected\n        emit Transfer(_from, _to, (_value.sub(_fee)));                                      // Transfer event\n        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {\n            emit Transfer(_from, address(this), _fee);                                      // Fee Transfer event\n        }\n    }\n    // Calculate Fee amount\n    function _getFee(address _from, address _to, uint _value) private view returns (uint) {\n        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {\n           return 0;                                                                        // No fee if excluded\n        } else {\n            return (_value / 1000);                                                         // Fee amount = 0.1%\n        }\n    }\n\n    //=======================================UPGRADE========================================//\n    // Allow to query for remaining upgrade amount\n    function getRemainingAmount() public view returns (uint amount){\n        uint maxEmissions = (upgradeHeight-1) * mapEra_Emission[1];                         // Max Emission on Old Contract\n        uint maxUpgradeAmount = (maxEmissions).sub(VETH(vether2).totalFees());              // Minus any collected fees\n        if(maxUpgradeAmount >= upgradedAmount){\n            return maxUpgradeAmount.sub(upgradedAmount);                                    // Return remaining\n        } else {\n            return 0;                                                                       // Return 0\n        }\n    }\n    // V1 upgrades \n    function upgradeV1() public {\n        uint amount = ERC20(vether1).balanceOf(msg.sender);                                 // Get Balance Vether1\n        if(amount > 0){\n            if(mapPreviousOwnership[msg.sender] < amount){\n                amount = mapPreviousOwnership[msg.sender];                                  // Upgrade as much as possible\n            } \n            uint remainingAmount = getRemainingAmount();\n            if(remainingAmount < amount){amount = remainingAmount;}                         // Handle final amount\n            upgradedAmount += amount; \n            mapPreviousOwnership[msg.sender] = mapPreviousOwnership[msg.sender].sub(amount);    // Update mappings\n            ERC20(vether1).transferFrom(msg.sender, burnAddress, amount);                   // Must collect & burn tokens\n            _transfer(address(this), msg.sender, amount);                                   // Send to owner\n        }\n    }\n    // V2 upgrades \n    function upgradeV2() public {\n        uint amount = ERC20(vether2).balanceOf(msg.sender);                                 // Get Balance Vether2\n        if(amount > 0){\n            if(mapPreviousOwnership[msg.sender] < amount){\n                amount = mapPreviousOwnership[msg.sender];                                  // Upgrade as much as possible\n            } \n            uint remainingAmount = getRemainingAmount();\n            if(remainingAmount < amount){amount = remainingAmount;}                         // Handle final amount\n            upgradedAmount += amount; \n            mapPreviousOwnership[msg.sender] = mapPreviousOwnership[msg.sender].sub(amount);    // Update mappings\n            ERC20(vether2).transferFrom(msg.sender, burnAddress, amount);                   // Must collect & burn tokens\n            _transfer(address(this), msg.sender, amount);                                   // Send to owner\n        }\n    }\n    // Snapshot previous owners\n    function snapshot(address[] memory owners, uint[] memory ownership) public{\n        require(msg.sender == deployer);\n        for(uint i = 0; i<owners.length; i++){\n            mapPreviousOwnership[owners[i]] += ownership[i];\n        }\n    }\n    // purge\n    function purgeDeployer() public{require(msg.sender == deployer);deployer = address(0);}\n\n    //==================================PROOF-OF-VALUE======================================//\n    // Calls when sending Ether\n    receive() external payable {\n        burnAddress.call.value(msg.value)(\"\");                                              // Burn ether\n        _recordBurn(msg.sender, msg.sender, currentEra, currentDay, msg.value);             // Record Burn\n    }\n    // Burn ether for nominated member\n    function burnEtherForMember(address member) external payable {\n        burnAddress.call.value(msg.value)(\"\");                                              // Burn ether\n        _recordBurn(msg.sender, member, currentEra, currentDay, msg.value);                 // Record Burn\n    }\n    // Internal - Records burn\n    function _recordBurn(address _payer, address _member, uint _era, uint _day, uint _eth) private {\n        require(VETH(vether2).currentDay() >= upgradeHeight || VETH(vether2).currentEra() > 1); // Prohibit until upgrade height\n        if (mapEraDay_MemberUnits[_era][_day][_member] == 0){                               // If hasn't contributed to this Day yet\n            mapMemberEra_Days[_member][_era].push(_day);                                    // Add it\n            mapEraDay_MemberCount[_era][_day] += 1;                                         // Count member\n            mapEraDay_Members[_era][_day].push(_member);                                    // Add member\n        }\n        mapEraDay_MemberUnits[_era][_day][_member] += _eth;                                 // Add member's share\n        mapEraDay_UnitsRemaining[_era][_day] += _eth;                                       // Add to total historicals\n        mapEraDay_Units[_era][_day] += _eth;                                                // Add to total outstanding\n        totalBurnt += _eth;                                                                 // Add to total burnt\n        emit Burn(_payer, _member, _era, _day, _eth, mapEraDay_Units[_era][_day]);          // Burn event\n        _updateEmission();                                                                  // Update emission Schedule\n    }\n    // Allows changing an excluded address\n    function changeExcluded(address excluded) external {    \n        if(!mapAddress_Excluded[excluded]){\n            _transfer(msg.sender, address(this), mapEra_Emission[1]/16);                    // Pay fee of 128 Vether\n            mapAddress_Excluded[excluded] = true;                                           // Add desired address\n            excludedArray.push(excluded); excludedCount +=1;                                // Record details\n            totalFees += mapEra_Emission[1]/16;                                             // Record fees\n            mapAddress_BlockChange[excluded] = block.number;                                // Record time of change\n        } else {\n            _transfer(msg.sender, address(this), mapEra_Emission[1]/32);                    // Pay fee of 64 Vether\n            mapAddress_Excluded[excluded] = false;                                          // Change desired address\n            totalFees += mapEra_Emission[1]/32;                                             // Record fees\n            mapAddress_BlockChange[excluded] = block.number;                                // Record time of change\n        }               \n    }\n    //======================================WITHDRAWAL======================================//\n    // Used to efficiently track participation in each era\n    function getDaysContributedForEra(address member, uint era) public view returns(uint){\n        return mapMemberEra_Days[member][era].length;\n    }\n    // Call to withdraw a claim\n    function withdrawShare(uint era, uint day) external returns (uint value) {\n        value = _withdrawShare(era, day, msg.sender);                           \n    }\n    // Call to withdraw a claim for another member\n    function withdrawShareForMember(uint era, uint day, address member) external returns (uint value) {\n        value = _withdrawShare(era, day, member);\n    }\n    // Internal - withdraw function\n    function _withdrawShare (uint _era, uint _day, address _member) private returns (uint value) {\n        _updateEmission(); \n        if (_era < currentEra) {                                                            // Allow if in previous Era\n            value = _processWithdrawal(_era, _day, _member);                                // Process Withdrawal\n        } else if (_era == currentEra) {                                                    // Handle if in current Era\n            if (_day < currentDay) {                                                        // Allow only if in previous Day\n                value = _processWithdrawal(_era, _day, _member);                            // Process Withdrawal\n            }\n        }  \n        return value;\n    }\n    // Internal - Withdrawal function\n    function _processWithdrawal (uint _era, uint _day, address _member) private returns (uint value) {\n        uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member];                      // Get Member Units\n        if (memberUnits == 0) { \n            value = 0;                                                                      // Do nothing if 0 (prevents revert)\n        } else {\n            value = getEmissionShare(_era, _day, _member);                                  // Get the emission Share for Member\n            mapEraDay_MemberUnits[_era][_day][_member] = 0;                                 // Set to 0 since it will be withdrawn\n            mapEraDay_UnitsRemaining[_era][_day] = mapEraDay_UnitsRemaining[_era][_day].sub(memberUnits);  // Decrement Member Units\n            mapEraDay_EmissionRemaining[_era][_day] = mapEraDay_EmissionRemaining[_era][_day].sub(value);  // Decrement emission\n            totalEmitted += value;                                                          // Add to Total Emitted\n            _transfer(address(this), _member, value);                                       // ERC20 transfer function\n            emit Withdrawal(msg.sender, _member, _era, _day, \n            value, mapEraDay_EmissionRemaining[_era][_day]);\n        }\n        return value;\n    }\n    // Get emission Share function\n    function getEmissionShare(uint era, uint day, address member) public view returns (uint value) {\n        uint memberUnits = mapEraDay_MemberUnits[era][day][member];                         // Get Member Units\n        if (memberUnits == 0) {\n            return 0;                                                                       // If 0, return 0\n        } else {\n            uint totalUnits = mapEraDay_UnitsRemaining[era][day];                           // Get Total Units\n            uint emissionRemaining = mapEraDay_EmissionRemaining[era][day];                 // Get emission remaining for Day\n            uint balance = _balances[address(this)];                                        // Find remaining balance\n            if (emissionRemaining > balance) { emissionRemaining = balance; }               // In case less than required emission\n            value = (emissionRemaining * memberUnits) / totalUnits;                         // Calculate share\n            return  value;                            \n        }\n    }\n    //======================================EMISSION========================================//\n    // Internal - Update emission function\n    function _updateEmission() private {\n        uint _now = now;                                                                    // Find now()\n        if (_now >= nextDayTime) {                                                          // If time passed the next Day time\n            if (currentDay >= daysPerEra) {                                                 // If time passed the next Era time\n                currentEra += 1; currentDay = 0;                                            // Increment Era, reset Day\n                nextEraTime = _now + (secondsPerDay * daysPerEra);                          // Set next Era time\n                emission = getNextEraEmission();                                            // Get correct emission\n                mapEra_Emission[currentEra] = emission;                                     // Map emission to Era\n                emit NewEra(currentEra, emission, nextEraTime, totalBurnt);                 // Emit Event\n            }\n            currentDay += 1;                                                                // Increment Day\n            nextDayTime = _now + secondsPerDay;                                             // Set next Day time\n            emission = getDayEmission();                                                    // Check daily Dmission\n            mapEraDay_EmissionRemaining[currentEra][currentDay] = emission;                 // Map emission to Day\n            uint _era = currentEra; uint _day = currentDay-1;\n            if(currentDay == 1){ _era = currentEra-1; _day = daysPerEra; }                  // Handle New Era\n            emit NewDay(currentEra, currentDay, nextDayTime, \n            mapEraDay_Units[_era][_day], mapEraDay_MemberCount[_era][_day]);                // Emit Event\n        }\n    }\n    // Calculate Era emission\n    function getNextEraEmission() public view returns (uint) {\n        if (emission > coin) {                                                              // Normal Emission Schedule\n            return emission / 2;                                                            // Emissions: 2048 -> 1.0\n        } else{                                                                             // Enters Fee Era\n            return coin;                                                                    // Return 1.0 from fees\n        }\n    }\n    // Calculate Day emission\n    function getDayEmission() public view returns (uint) {\n        uint balance = _balances[address(this)];                                            // Find remaining balance\n        if (balance > emission) {                                                           // Balance is sufficient\n            return emission;                                                                // Return emission\n        } else {                                                                            // Balance has dropped low\n            return balance;                                                                 // Return full balance\n        }\n    }\n}"
    },
    "contracts/Vether4.sol": {
      "content": "pragma solidity 0.6.4;\n//ERC20 Interface\ninterface ERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address, uint) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    }\ninterface VETH {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint);\n    function totalSupply() external view returns (uint);\n    function genesis() external view returns (uint);\n    function currentEra() external view returns (uint);\n    function currentDay() external view returns (uint);\n    function emission() external view returns (uint);\n    function daysPerEra() external view returns (uint);\n    function secondsPerDay() external view returns (uint);\n    function nextDayTime() external view returns (uint);\n    function totalBurnt() external view returns (uint);\n    function totalFees() external view returns (uint);\n    function burnAddress() external view returns (address payable);\n    function upgradeHeight() external view returns (uint);\n    function mapEraDay_Units(uint, uint) external view returns (uint);\n    function mapPreviousOwnership(address payable) external view returns (uint);\n}\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n}\n    //======================================VETHER=========================================//\ncontract Vether4 is ERC20 {\n    using SafeMath for uint;\n    // ERC-20 Parameters\n    string public name; string public symbol;\n    uint public decimals; uint public override totalSupply;\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n    // Public Parameters\n    uint coin = 1; uint public emission;\n    uint public currentEra; uint public currentDay;\n    uint public daysPerEra; uint public secondsPerDay;\n    uint public upgradeHeight; uint public upgradedAmount;\n    uint public genesis; uint public nextEraTime; uint public nextDayTime;\n    address payable public burnAddress; address deployer;\n    address public vether1; address public vether2;\n    uint public totalFees; uint public totalBurnt; uint public totalEmitted;\n    address[] public holderArray; uint public holders;\n    address[] public excludedArray; uint public excludedCount;\n    // Public Mappings\n    mapping(uint=>uint) public mapEra_Emission;                                             // Era->Emission\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_MemberCount;                        // Era,Days->MemberCount\n    mapping(uint=>mapping(uint=>address[])) public mapEraDay_Members;                       // Era,Days->Members\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_Units;                              // Era,Days->Units\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_UnitsRemaining;                     // Era,Days->TotalUnits\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_EmissionRemaining;                  // Era,Days->Emission\n    mapping(uint=>mapping(uint=>mapping(address=>uint))) public mapEraDay_MemberUnits;      // Era,Days,Member->Units\n    mapping(address=>mapping(uint=>uint[])) public mapMemberEra_Days;                       // Member,Era->Days[]\n    mapping(address=>uint) public mapPreviousOwnership;                                     // Map previous owners\n    mapping(address=>bool) public mapHolder;                                                // Vether Holder\n    mapping(address=>bool) public mapAddress_Excluded;                                      // Address->Excluded\n    // Events\n    event NewEra(uint era, uint emission, uint time, uint totalBurnt);\n    event NewDay(uint era, uint day, uint time, uint previousDayTotal, uint previousDayMembers);\n    event Burn(address indexed payer, address indexed member, uint era, uint day, uint units, uint dailyTotal);\n    event Withdrawal(address indexed caller, address indexed member, uint era, uint day, uint value, uint vetherRemaining);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor(address _vether1, address _vether2) public {\n        vether1 = _vether1;                                // First Vether\n        vether2 = _vether2;                                // Second Vether\n        upgradeHeight = 5;                                                                  // Height at which to upgrade\n        name = VETH(vether2).name(); symbol = VETH(vether2).symbol();\n        decimals = VETH(vether2).decimals(); totalSupply = VETH(vether2).totalSupply();\n        genesis = VETH(vether2).genesis(); emission = VETH(vether2).emission(); \n        currentEra = VETH(vether2).currentEra(); currentDay = upgradeHeight;                // Begin at Upgrade Height\n        daysPerEra = VETH(vether2).daysPerEra(); secondsPerDay = VETH(vether2).secondsPerDay();\n        totalBurnt = VETH(vether2).totalBurnt(); totalFees = VETH(vether2).totalFees();\n        totalEmitted = (upgradeHeight-1)*emission;\n        burnAddress = VETH(vether2).burnAddress(); deployer = msg.sender;\n        _balances[address(this)] = totalSupply; \n        emit Transfer(burnAddress, address(this), totalSupply);\n        nextEraTime = genesis + (secondsPerDay * daysPerEra);\n        nextDayTime = now + secondsPerDay;\n        mapAddress_Excluded[address(this)] = true;                                          \n        excludedArray.push(address(this)); excludedCount = 1;                               \n        mapAddress_Excluded[burnAddress] = true;\n        excludedArray.push(burnAddress); excludedCount +=1; \n        mapEra_Emission[currentEra] = emission; \n        mapEraDay_EmissionRemaining[currentEra][currentDay] = emission; \n        _setMappings();                                                                  // Map historical units\n    }\n    function _setMappings() internal {\n        uint upgradeHeight1 = VETH(vether2).upgradeHeight();                \n        for(uint i=0;i<upgradeHeight1; i++) {\n            mapEraDay_Units[1][i] = VETH(vether1).mapEraDay_Units(1,i); \n        }\n        for(uint i=upgradeHeight1;i<upgradeHeight; i++) {\n            mapEraDay_Units[1][i] = VETH(vether2).mapEraDay_Units(1,i); \n        }\n    }\n\n    //========================================ERC20=========================================//\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    // ERC20 Transfer function\n    function transfer(address to, uint value) public override returns (bool success) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n    // ERC20 Approve function\n    function approve(address spender, uint value) public override returns (bool success) {\n        _allowances[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n    // ERC20 TransferFrom function\n    function transferFrom(address from, address to, uint value) public override returns (bool success) {\n        require(value <= _allowances[from][msg.sender], 'Must not send more than allowance');\n        _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        return true;\n    }\n    // Internal transfer function which includes the Fee\n    function _transfer(address _from, address _to, uint _value) private {\n        require(_balances[_from] >= _value, 'Must not send more than balance');\n        require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');\n        if(!mapHolder[_to]){holderArray.push(_to); holders+=1; mapHolder[_to]=true;}\n        _balances[_from] =_balances[_from].sub(_value);\n        uint _fee = _getFee(_from, _to, _value);                                            // Get fee amount\n        _balances[_to] += (_value.sub(_fee));                                               // Add to receiver\n        _balances[address(this)] += _fee;                                                   // Add fee to self\n        totalFees += _fee;                                                                  // Track fees collected\n        emit Transfer(_from, _to, (_value.sub(_fee)));                                      // Transfer event\n        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {\n            emit Transfer(_from, address(this), _fee);                                      // Fee Transfer event\n        }\n    }\n    // Calculate Fee amount\n    function _getFee(address _from, address _to, uint _value) private view returns (uint) {\n        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {\n           return 0;                                                                        // No fee if excluded\n        } else {\n            return (_value / 1000);                                                         // Fee amount = 0.1%\n        }\n    }\n\n    //=======================================UPGRADE========================================//\n    // Allow to query for remaining upgrade amount\n    function getRemainingAmount() public view returns (uint amount){\n        uint maxEmissions = (upgradeHeight-1) * mapEra_Emission[1];                         // Max Emission on Old Contract\n        uint maxUpgradeAmount = (maxEmissions).sub(VETH(vether2).totalFees());              // Minus any collected fees\n        if(maxUpgradeAmount >= upgradedAmount){\n            return maxUpgradeAmount.sub(upgradedAmount);                                    // Return remaining\n        } else {\n            return 0;                                                                       // Return 0\n        }\n    }\n    // Claim Vether based on snapshot\n    function claim() public {\n        uint amount = mapPreviousOwnership[msg.sender];\n        if(amount > 0){\n            uint remainingAmount = getRemainingAmount();\n            if(remainingAmount < amount){amount = remainingAmount;}                         // Handle final amount\n            upgradedAmount += amount; \n            mapPreviousOwnership[msg.sender] = 0;                                           // Update mappings\n            _transfer(address(this), msg.sender, amount);                                   // Send to owner\n        }\n    }\n    // Snapshot previous owners\n    function snapshot(address[] memory owners, uint[] memory ownership) public{\n        require(msg.sender == deployer);\n        for(uint i = 0; i<owners.length; i++){\n            mapPreviousOwnership[owners[i]] += ownership[i];\n        }\n    }\n    // purge\n    function purgeDeployer() public{require(msg.sender == deployer);deployer = address(0);}\n\n    //==================================PROOF-OF-VALUE======================================//\n    // Calls when sending Ether\n    receive() external payable {\n        burnAddress.call.value(msg.value)(\"\");                                              // Burn ether\n        _recordBurn(msg.sender, msg.sender, currentEra, currentDay, msg.value);             // Record Burn\n    }\n    // Burn ether for nominated member\n    function burnEtherForMember(address member) external payable {\n        burnAddress.call.value(msg.value)(\"\");                                              // Burn ether\n        _recordBurn(msg.sender, member, currentEra, currentDay, msg.value);                 // Record Burn\n    }\n    // Internal - Records burn\n    function _recordBurn(address _payer, address _member, uint _era, uint _day, uint _eth) private {\n        if (mapEraDay_MemberUnits[_era][_day][_member] == 0){                               // If hasn't contributed to this Day yet\n            mapMemberEra_Days[_member][_era].push(_day);                                    // Add it\n            mapEraDay_MemberCount[_era][_day] += 1;                                         // Count member\n            mapEraDay_Members[_era][_day].push(_member);                                    // Add member\n        }\n        mapEraDay_MemberUnits[_era][_day][_member] += _eth;                                 // Add member's share\n        mapEraDay_UnitsRemaining[_era][_day] += _eth;                                       // Add to total historicals\n        mapEraDay_Units[_era][_day] += _eth;                                                // Add to total outstanding\n        totalBurnt += _eth;                                                                 // Add to total burnt\n        emit Burn(_payer, _member, _era, _day, _eth, mapEraDay_Units[_era][_day]);          // Burn event\n        _updateEmission();                                                                  // Update emission Schedule\n    }\n    // Allows changing an excluded address\n    function addExcluded(address excluded) external {    \n        if(!mapAddress_Excluded[excluded]){\n            _transfer(msg.sender, address(this), mapEra_Emission[1]/16);                    // Pay fee of 128 Vether\n            mapAddress_Excluded[excluded] = true;                                           // Add desired address\n            excludedArray.push(excluded); excludedCount +=1;                                // Record details\n            totalFees += mapEra_Emission[1]/16;                                             // Record fees\n        }              \n    }\n    //======================================WITHDRAWAL======================================//\n    // Used to efficiently track participation in each era\n    function getDaysContributedForEra(address member, uint era) public view returns(uint){\n        return mapMemberEra_Days[member][era].length;\n    }\n    // Call to withdraw a claim\n    function withdrawShare(uint era, uint day) external returns (uint value) {\n        value = _withdrawShare(era, day, msg.sender);                           \n    }\n    // Call to withdraw a claim for another member\n    function withdrawShareForMember(uint era, uint day, address member) external returns (uint value) {\n        value = _withdrawShare(era, day, member);\n    }\n    // Internal - withdraw function\n    function _withdrawShare (uint _era, uint _day, address _member) private returns (uint value) {\n        _updateEmission(); \n        if (_era < currentEra) {                                                            // Allow if in previous Era\n            value = _processWithdrawal(_era, _day, _member);                                // Process Withdrawal\n        } else if (_era == currentEra) {                                                    // Handle if in current Era\n            if (_day < currentDay) {                                                        // Allow only if in previous Day\n                value = _processWithdrawal(_era, _day, _member);                            // Process Withdrawal\n            }\n        }  \n        return value;\n    }\n    // Internal - Withdrawal function\n    function _processWithdrawal (uint _era, uint _day, address _member) private returns (uint value) {\n        uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member];                      // Get Member Units\n        if (memberUnits == 0) { \n            value = 0;                                                                      // Do nothing if 0 (prevents revert)\n        } else {\n            value = getEmissionShare(_era, _day, _member);                                  // Get the emission Share for Member\n            mapEraDay_MemberUnits[_era][_day][_member] = 0;                                 // Set to 0 since it will be withdrawn\n            mapEraDay_UnitsRemaining[_era][_day] = mapEraDay_UnitsRemaining[_era][_day].sub(memberUnits);  // Decrement Member Units\n            mapEraDay_EmissionRemaining[_era][_day] = mapEraDay_EmissionRemaining[_era][_day].sub(value);  // Decrement emission\n            totalEmitted += value;                                                          // Add to Total Emitted\n            _transfer(address(this), _member, value);                                       // ERC20 transfer function\n            emit Withdrawal(msg.sender, _member, _era, _day, \n            value, mapEraDay_EmissionRemaining[_era][_day]);\n        }\n        return value;\n    }\n    // Get emission Share function\n    function getEmissionShare(uint era, uint day, address member) public view returns (uint value) {\n        uint memberUnits = mapEraDay_MemberUnits[era][day][member];                         // Get Member Units\n        if (memberUnits == 0) {\n            return 0;                                                                       // If 0, return 0\n        } else {\n            uint totalUnits = mapEraDay_UnitsRemaining[era][day];                           // Get Total Units\n            uint emissionRemaining = mapEraDay_EmissionRemaining[era][day];                 // Get emission remaining for Day\n            uint balance = _balances[address(this)];                                        // Find remaining balance\n            if (emissionRemaining > balance) { emissionRemaining = balance; }               // In case less than required emission\n            value = (emissionRemaining * memberUnits) / totalUnits;                         // Calculate share\n            return  value;                            \n        }\n    }\n    //======================================EMISSION========================================//\n    // Internal - Update emission function\n    function _updateEmission() private {\n        uint _now = now;                                                                    // Find now()\n        if (_now >= nextDayTime) {                                                          // If time passed the next Day time\n            if (currentDay >= daysPerEra) {                                                 // If time passed the next Era time\n                currentEra += 1; currentDay = 0;                                            // Increment Era, reset Day\n                nextEraTime = _now + (secondsPerDay * daysPerEra);                          // Set next Era time\n                emission = getNextEraEmission();                                            // Get correct emission\n                mapEra_Emission[currentEra] = emission;                                     // Map emission to Era\n                emit NewEra(currentEra, emission, nextEraTime, totalBurnt);                 // Emit Event\n            }\n            currentDay += 1;                                                                // Increment Day\n            nextDayTime = _now + secondsPerDay;                                             // Set next Day time\n            emission = getDayEmission();                                                    // Check daily Dmission\n            mapEraDay_EmissionRemaining[currentEra][currentDay] = emission;                 // Map emission to Day\n            uint _era = currentEra; uint _day = currentDay-1;\n            if(currentDay == 1){ _era = currentEra-1; _day = daysPerEra; }                  // Handle New Era\n            emit NewDay(currentEra, currentDay, nextDayTime, \n            mapEraDay_Units[_era][_day], mapEraDay_MemberCount[_era][_day]);                // Emit Event\n        }\n    }\n    // Calculate Era emission\n    function getNextEraEmission() public view returns (uint) {\n        if (emission > coin) {                                                              // Normal Emission Schedule\n            return emission / 2;                                                            // Emissions: 2048 -> 1.0\n        } else{                                                                             // Enters Fee Era\n            return coin;                                                                    // Return 1.0 from fees\n        }\n    }\n    // Calculate Day emission\n    function getDayEmission() public view returns (uint) {\n        uint balance = _balances[address(this)];                                            // Find remaining balance\n        if (balance > emission) {                                                           // Balance is sufficient\n            return emission;                                                                // Return emission\n        } else {                                                                            // Balance has dropped low\n            return balance;                                                                 // Return full balance\n        }\n    }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}